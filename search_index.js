var documenterSearchIndex = {"docs":
[{"location":"lib/edge/#Edges","page":"Edges","title":"Edges","text":"","category":"section"},{"location":"lib/edge/#Types","page":"Edges","title":"Types","text":"","category":"section"},{"location":"lib/edge/","page":"Edges","title":"Edges","text":"Modules = [PanGraph.Graphs.Edges]\nOrder = [:type, :constant]","category":"page"},{"location":"lib/edge/#PanGraph.Graphs.Edges.Edge","page":"Edges","title":"PanGraph.Graphs.Edges.Edge","text":"mutable struct Edge\n    block  :: Tuple{Block, Block}\n    invert :: Bool # changes strand\n    nodes  :: Array{Position}\nend\n\nStore a unique edge within a pangraph. An edge is undirected and is defined by the two juxtaposed blocks, as well as a relative orientation. Contain all positions of all genomes that contain the edge.\n\n\n\n\n\n","category":"type"},{"location":"lib/edge/#PanGraph.Graphs.Edges.Position","page":"Edges","title":"PanGraph.Graphs.Edges.Position","text":"struct Position\n    path  :: Path\n    node  :: Tuple{Node{Block},Node{Block}}\n    index :: Tuple{Int,Int} # positions on path\n    locus :: Int # breakpoint on sequence\nend\n\nStore a single position of an edge/breakpoint between homologous pancontigs in an individual genome. path is the containing Path object. node stores the junction of nodes that represent the position of the breakpoint. index is the indices of node within path. locus is the physical location on the genome of the breakpoint.\n\n\n\n\n\n","category":"type"},{"location":"lib/edge/#Functions","page":"Edges","title":"Functions","text":"","category":"section"},{"location":"lib/edge/","page":"Edges","title":"Edges","text":"Modules = [PanGraph.Graphs.Edges]\nOrder = [:function]","category":"page"},{"location":"lib/edge/#PanGraph.Graphs.Edges.deparalog!-Tuple{Any}","page":"Edges","title":"PanGraph.Graphs.Edges.deparalog!","text":"deparalog!(G)\n\nSplit duplicated blocks that have non-intersecting, seperable paths that run in parallel and transitively connect associated genomes. Use to simplify high copy number blocks found in all individuals in equivalent contexts within pangraph G.\n\n\n\n\n\n","category":"method"},{"location":"lib/edge/#PanGraph.Graphs.Edges.edges-Tuple{Any}","page":"Edges","title":"PanGraph.Graphs.Edges.edges","text":"edges(G)\n\nCompute all edges associated with pangraph G.\n\n\n\n\n\n","category":"method"},{"location":"lib/edge/#PanGraph.Graphs.Edges.isolates-Tuple{Vector{PanGraph.Graphs.Edges.Position}}","page":"Edges","title":"PanGraph.Graphs.Edges.isolates","text":"isolates(positions::Array{Position,1})\n\nCompute the array of Position values for each isolate.\n\n\n\n\n\n","category":"method"},{"location":"lib/edge/#PanGraph.Graphs.Edges.next-Tuple{PanGraph.Graphs.Edges.Position, PanGraph.Graphs.Blocks.Block}","page":"Edges","title":"PanGraph.Graphs.Edges.next","text":"next(x::Position, blk::Block)\n\nCompute the next position from x that is connected through block blk. Use to traverse the path of an individual genome through a pangraph.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#Blocks","page":"Blocks","title":"Blocks","text":"","category":"section"},{"location":"lib/block/#Types","page":"Blocks","title":"Types","text":"","category":"section"},{"location":"lib/block/","page":"Blocks","title":"Blocks","text":"Modules = [PanGraph.Graphs.Blocks]\nOrder = [:type, :constant]","category":"page"},{"location":"lib/block/#PanGraph.Graphs.Blocks.Block","page":"Blocks","title":"PanGraph.Graphs.Blocks.Block","text":"mutable struct Block\n    uuid     :: String\n    sequence :: Array{UInt8}\n    gaps     :: Dict{Int,Int}\n    mutate   :: Dict{Node{Block},SNPMap}\n    insert   :: Dict{Node{Block},InsMap}\n    delete   :: Dict{Node{Block},DelMap}\nend\n\nStore a multiple sequence alignment of contiguous DNA related by homology. Use as a component of a larger, branching multiple genome alignment. uuid is a string identifier unique to each block sequence is the consensus (majority-rule) sequence gaps recapitulate all locations of insertions for generating the full sequence alignment. mutate, insert, and delete store polymorphisms of each genome contained within the block.\n\n\n\n\n\n","category":"type"},{"location":"lib/block/#PanGraph.Graphs.Blocks.Block-NTuple{5, Any}","page":"Blocks","title":"PanGraph.Graphs.Blocks.Block","text":"Block(sequence,gaps,mutate,insert,delete)\n\nConstruct a block with a unique uuid.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.Block-Tuple{Any, Any}","page":"Blocks","title":"PanGraph.Graphs.Blocks.Block","text":"Block(sequence,gaps)\n\nConstruct a block with a unique uuid with fixed sequence and gaps. No individuals and thus polymorphisms are initialized.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.Block-Tuple{Any}","page":"Blocks","title":"PanGraph.Graphs.Blocks.Block","text":"Block(sequence,gaps)\n\nConstruct a block with a unique uuid with fixed sequence.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.Block-Tuple{PanGraph.Graphs.Blocks.Block, Any}","page":"Blocks","title":"PanGraph.Graphs.Blocks.Block","text":"Block(b::Block, slice)\n\nReturn a subsequence associated to block b at interval slice. The returned block has a newly generated uuid.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.Block-Tuple{Vararg{PanGraph.Graphs.Blocks.Block, N} where N}","page":"Blocks","title":"PanGraph.Graphs.Blocks.Block","text":"Block(bs::Block...)\n\nConcatenate a variable number of blocks into one larger block. The returned block has a newly generated uuid.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.Block-Tuple{}","page":"Blocks","title":"PanGraph.Graphs.Blocks.Block","text":"Block(sequence,gaps)\n\nConstruct a block with a unique uuid. All fields are empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.PairPos","page":"Blocks","title":"PanGraph.Graphs.Blocks.PairPos","text":"mutable struct PairPos\n    qry :: Maybe{Pos}\n    ref :: Maybe{Pos}\nend\n\nRepresentation of matched pair of intervals within a pairwise alignment. qry can be of type Pos or Nothing ref can be of type Pos or Nothing If either ref or qry is nothing, the PairPos corresponds to an insertion or deletion respectively.\n\n\n\n\n\n","category":"type"},{"location":"lib/block/#PanGraph.Graphs.Blocks.Pos","page":"Blocks","title":"PanGraph.Graphs.Blocks.Pos","text":"mutable struct Pos\n    start :: Int\n    stop  :: Int\nend\n\nRepresentation of a single interval within a pairwise alignment. Inclusive on both ends, i.e. includes start and stop Used internally to unpack cigar strings.\n\n\n\n\n\n","category":"type"},{"location":"lib/block/#Functions","page":"Blocks","title":"Functions","text":"","category":"section"},{"location":"lib/block/","page":"Blocks","title":"Blocks","text":"Modules = [PanGraph.Graphs.Blocks]\nOrder = [:function]","category":"page"},{"location":"lib/block/#Base.append!-Tuple{PanGraph.Graphs.Blocks.Block, PanGraph.Graphs.Nodes.Node{PanGraph.Graphs.Blocks.Block}, Union{Nothing, Dict{Int64, UInt8}}, Union{Nothing, Dict{Tuple{Int64, Int64}, Vector{UInt8}}}, Union{Nothing, Dict{Int64, Int64}}}","page":"Blocks","title":"Base.append!","text":"append!(b::Block, node::Node{Block}, snp::Maybe{SNPMap}, ins::Maybe{InsMap}, del::Maybe{DelMap})\n\nAdds a new genome at node to multiple sequence alignment block b. Polymorphisms are optional. If nothing is passed instead, an empty dictionary will be used.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#Base.length-Tuple{PanGraph.Graphs.Blocks.Block, PanGraph.Graphs.Nodes.Node}","page":"Blocks","title":"Base.length","text":"length(b::Block, n::Node)\n\nReturn the length of the sequence of node n within the multiple alignment of block b.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#Base.length-Tuple{PanGraph.Graphs.Blocks.Block}","page":"Blocks","title":"Base.length","text":"length(b::Block)\n\nReturn the length of consensus sequence of the multiple alignment of block b.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#Base.pop!-Tuple{PanGraph.Graphs.Blocks.Block, PanGraph.Graphs.Nodes.Node}","page":"Blocks","title":"Base.pop!","text":"pop!(b::Block, n::Node)\n\nRemove genome of Node n from Block b.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.allele_positions-Tuple{Dict{Int64, UInt8}, Dict{Tuple{Int64, Int64}, Vector{UInt8}}, Dict{Int64, Int64}}","page":"Blocks","title":"PanGraph.Graphs.Blocks.allele_positions","text":"allele_positions(snp::SNPMap, ins::InsMap, del::DelMap)\n\nReturn an iterator over polymorphic loci, i.e. SNPs and Indels. The iterator will be sorted by position in ascending order.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.allele_positions-Tuple{PanGraph.Graphs.Blocks.Block, PanGraph.Graphs.Nodes.Node}","page":"Blocks","title":"PanGraph.Graphs.Blocks.allele_positions","text":"allele_positions(b::Block, n::Node)\n\nReturn an iterator over polymorphic loci for node n contained within block b The iterator will be sorted by position in ascending order.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.applyalleles-NTuple{4, Any}","page":"Blocks","title":"PanGraph.Graphs.Blocks.applyalleles","text":"applyalleles(seq::Array{UInt8}, mutate::SNPMap, insert::InsMap, delete::DelMap)\n\nTake a sequence and apply polymorphisms, as given by mutate, insert, and delete. Return the brand new allocated sequence.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.assert_equals-Tuple{PanGraph.Graphs.Blocks.Block, PanGraph.Graphs.Blocks.Block}","page":"Blocks","title":"PanGraph.Graphs.Blocks.assert_equals","text":"assert_equal(b₁::Block, b₂::Block)\n\nThrow an error in block b₁ is not equivalent to block b₂. Useful for internal debugging.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.check-Tuple{PanGraph.Graphs.Blocks.Block}","page":"Blocks","title":"PanGraph.Graphs.Blocks.check","text":"check(b::Block)\n\nCheck whether block b is internally self-consistent. Useful for debugging internals.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.combine-Tuple{PanGraph.Graphs.Blocks.Block, PanGraph.Graphs.Blocks.Block, PanGraph.Graphs.Utility.Alignment}","page":"Blocks","title":"PanGraph.Graphs.Blocks.combine","text":"combine(qry::Block, ref::Block, aln::Alignment; minblock=500)\n\nTake a pairwise alignment aln from the consensus of qry to ref and merge both. The resultant new block, with a novel uuid is returned. Alignment aln is a segmented set of intervals mapping homologous regions of one block into the other. Parameter minblock is the cutoff length of an indel, above which a new block will be created.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.depth-Tuple{PanGraph.Graphs.Blocks.Block}","page":"Blocks","title":"PanGraph.Graphs.Blocks.depth","text":"depth(b::Block)\n\nReturn the number of genomes contained within the alignment\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.diversity-Tuple{PanGraph.Graphs.Blocks.Block}","page":"Blocks","title":"PanGraph.Graphs.Blocks.diversity","text":"diversity(b::Block)\n\nReturn the averaged fraction of loci that are mutated within the multiple sequence alignment of block b.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.partition-Tuple{Any}","page":"Blocks","title":"PanGraph.Graphs.Blocks.partition","text":"partition(alignment; minblock=500)\n\nParse the alignment into matched intervals of a pairwise alignment. If any insertion or deletion is larger than minblock, a new block is created to hold the homologous interval. This ensures that all blocks are at least minblock long and no block contains an insertion or deletion longer than itself.\n\nalignment is assumed to be an data structure from the Utility module\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.reconsensus!-Tuple{PanGraph.Graphs.Blocks.Block}","page":"Blocks","title":"PanGraph.Graphs.Blocks.reconsensus!","text":"reconsensus!(b::Block)\n\nUpdate the consensus sequence of block b by majority-rule over the multiple sequence alignment.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.regap!-Tuple{PanGraph.Graphs.Blocks.Block}","page":"Blocks","title":"PanGraph.Graphs.Blocks.regap!","text":"regap!(b::Block)\n\nRecompute the positions of gaps within the multiple sequence of block b\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.rereference-Tuple{PanGraph.Graphs.Blocks.Block, PanGraph.Graphs.Blocks.Block, Any}","page":"Blocks","title":"PanGraph.Graphs.Blocks.rereference","text":"rerefence(qry::Block, ref::Block, aligment)\n\nTake a pairwise alignment segments from the consensus of qry to ref and rereference all polymorphisms of qry to the consensus sequence of `ref. Low-level function used by higher-level API.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.swap!-Tuple{PanGraph.Graphs.Blocks.Block, Array{PanGraph.Graphs.Nodes.Node{PanGraph.Graphs.Blocks.Block}, N} where N, PanGraph.Graphs.Nodes.Node{PanGraph.Graphs.Blocks.Block}}","page":"Blocks","title":"PanGraph.Graphs.Blocks.swap!","text":"swap!(b::Block, oldkey::Array{Node{Block}}, newkey::Node{Block})\n\nRemove all polymorphisms associated to all keys within oldkey. Concatenate and reassociate them to newkey.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.swap!-Tuple{PanGraph.Graphs.Blocks.Block, PanGraph.Graphs.Nodes.Node{PanGraph.Graphs.Blocks.Block}, PanGraph.Graphs.Nodes.Node{PanGraph.Graphs.Blocks.Block}}","page":"Blocks","title":"PanGraph.Graphs.Blocks.swap!","text":"swap!(b::Block, oldkey::Node{Block}, newkey::Node{Block})\n\nRemove all polymorphisms associated to oldkey and reassociate them to newkey.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.marshal_fasta-Tuple{IO, PanGraph.Graphs.Blocks.Block}","page":"Blocks","title":"PanGraph.Graphs.marshal_fasta","text":"marshal_fasta(io::IO, b::Block; opt=nothing)\n\nSerialize the multiple sequence alignment of block b to a fasta format to IO stream io. Each sequence will be serialized as-is, i.e. with no gaps.\n\nIf opt is not nothing, the output will be an aligned fasta file. Futhermore, opt is interpreted as a function to be called per internal node that gives a unique name for each fasta record that is generated per node.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.reverse_complement-Tuple{PanGraph.Graphs.Blocks.Block}","page":"Blocks","title":"PanGraph.Graphs.reverse_complement","text":"reverse_complement(b::Block; keepid=false)\n\nReturn the reverse complement of the multiple sequence alignment within Block b. By default, will return a block with a new uuid, unless keepid is set to true.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.sequence!-Tuple{Any, PanGraph.Graphs.Blocks.Block, PanGraph.Graphs.Nodes.Node{PanGraph.Graphs.Blocks.Block}}","page":"Blocks","title":"PanGraph.Graphs.sequence!","text":"sequence!(seq, b::Block, node::Node{Block}; gaps=false)\n\nMutate the sequence buffer seq in place to hold the sequence associated to genome node within sequence alignment of block b. By default, gaps (charater '-') will not be returned, unless gaps is set to true. Return the sequence with gap characters to generate the full sequence alignment.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.sequence-Tuple{PanGraph.Graphs.Blocks.Block, PanGraph.Graphs.Nodes.Node{PanGraph.Graphs.Blocks.Block}}","page":"Blocks","title":"PanGraph.Graphs.sequence","text":"sequence(seq, b::Block, node::Node{Block}; gaps=false, forward=false)\n\nReturn the sequence associated to genome node within sequence alignment of block b. By default, gaps (charater '-') will not be returned, unless gaps is set to true. Return the sequence with gap characters can be used to generate the full sequence alignment. If forward is true, the true orientation of the genome is ignored and will be returned to align to the forward consensus.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.sequence-Tuple{PanGraph.Graphs.Blocks.Block}","page":"Blocks","title":"PanGraph.Graphs.sequence","text":"sequence(b::Block; gaps=false)\n\nReturn the consensus of the multiple sequence alignment within block b. By default, gaps (charater '-') will not be returned, unless gaps is set to true. Return the consensus alignment with gaps is useful for generating the full sequence alignment.\n\n\n\n\n\n","category":"method"},{"location":"lib/gfa/#GFA","page":"GFA","title":"GFA","text":"","category":"section"},{"location":"lib/gfa/#Types","page":"GFA","title":"Types","text":"","category":"section"},{"location":"lib/gfa/","page":"GFA","title":"GFA","text":"Modules = [PanGraph.Graphs.GFA]\nOrder = [:type, :constant]","category":"page"},{"location":"lib/gfa/#PanGraph.Graphs.GFA.Path","page":"GFA","title":"PanGraph.Graphs.GFA.Path","text":"struct Path\n    name     :: String\n    segments :: Array{Node,1}\n    circular :: Bool\nend\n\nStore a GFA path, i.e. a sequence of segments that represents an observed genome.\n\n\n\n\n\n","category":"type"},{"location":"lib/gfa/#PanGraph.Graphs.GFA.Segment","page":"GFA","title":"PanGraph.Graphs.GFA.Segment","text":"struct Segment\n    name     :: String\n    sequence :: Array{UInt8}\n    depth    :: Int\nend\n\nStore a GFA segment, i.e. an edge of an alignment graph that holds a contiguous sequence Depth is the number of genomes, including duplications, that contain the sequence.\n\n\n\n\n\n","category":"type"},{"location":"lib/gfa/#Functions","page":"GFA","title":"Functions","text":"","category":"section"},{"location":"lib/gfa/","page":"GFA","title":"GFA","text":"Modules = [PanGraph.Graphs.GFA]\nOrder = [:function]","category":"page"},{"location":"lib/gfa/#PanGraph.Graphs.marshal_gfa-Tuple{IO, PanGraph.Graphs.Graph}","page":"GFA","title":"PanGraph.Graphs.marshal_gfa","text":"marshal_gfa(io::IO, G::Graph; opt=nothing)\n\nOutput pangraph G to IO stream io. opt can include two functions, to be accessed in fields connect and output. connect is a function that takes a node and returns true or false if it should be connected in the GFA output. output is an equivalent function signature, but controls whether the node is output at all.\n\n\n\n\n\n","category":"method"},{"location":"lib/node/#Nodes","page":"Nodes","title":"Nodes","text":"","category":"section"},{"location":"lib/node/#Types","page":"Nodes","title":"Types","text":"","category":"section"},{"location":"lib/node/","page":"Nodes","title":"Nodes","text":"Modules = [PanGraph.Graphs.Nodes]\nOrder = [:type, :constant]","category":"page"},{"location":"lib/node/#PanGraph.Graphs.Nodes.Node","page":"Nodes","title":"PanGraph.Graphs.Nodes.Node","text":"mutable struct Node{T}\n\tblock  :: T\n\tstrand :: Bool\nend\n\nNode represents a portion of a sequence path that passes through a single block. strand stores whether we pass along the forward strand of block (if true) or reverse (if false).\n\n\n\n\n\n","category":"type"},{"location":"lib/node/#PanGraph.Graphs.Nodes.Node-Tuple{T} where T","page":"Nodes","title":"PanGraph.Graphs.Nodes.Node","text":"Node{T}(b::T; strand=true)\n\nCreate a Node that passed through block b. Default to forward strand orientation.\n\n\n\n\n\n","category":"method"},{"location":"lib/node/#Functions","page":"Nodes","title":"Functions","text":"","category":"section"},{"location":"lib/node/","page":"Nodes","title":"Nodes","text":"Modules = [PanGraph.Graphs.Nodes]\nOrder = [:function]","category":"page"},{"location":"lib/node/#Base.length-Tuple{PanGraph.Graphs.Nodes.Node}","page":"Nodes","title":"Base.length","text":"length(n::Node) = length(n.block, n)\n\nReturn the length of sequence stored within node n\n\n\n\n\n\n","category":"method"},{"location":"lib/mash/#Mash-Implementation","page":"Mash Implementation","title":"Mash Implementation","text":"","category":"section"},{"location":"lib/mash/#Types","page":"Mash Implementation","title":"Types","text":"","category":"section"},{"location":"lib/mash/","page":"Mash Implementation","title":"Mash Implementation","text":"Modules = [PanGraph.Graphs.Mash]\nOrder = [:type, :constant]","category":"page"},{"location":"lib/mash/#PanGraph.Graphs.Mash.Minimizer","page":"Mash Implementation","title":"PanGraph.Graphs.Mash.Minimizer","text":"struct Minimizer\n    value    :: UInt64\n    position :: UInt64\nend\n\nA minimizer is a kmer that, given a hash function that maps kmers to integers, is the minimum kmer within a given set of kmers. The value is the result of applying the hash function to the kmer. The position is a bitpacked integer that includes reference ID, locus, and strand\n\n\n\n\n\n","category":"type"},{"location":"lib/mash/#Functions","page":"Mash Implementation","title":"Functions","text":"","category":"section"},{"location":"lib/mash/","page":"Mash Implementation","title":"Mash Implementation","text":"Modules = [PanGraph.Graphs.Mash]\nOrder = [:function]","category":"page"},{"location":"lib/mash/#PanGraph.Graphs.Mash.distance-Tuple","page":"Mash Implementation","title":"PanGraph.Graphs.Mash.distance","text":"distance(graphs...; k=15, w=100)\n\nCompute the pairwise distance between all input graphs. Distance is the set distance between minimizers. Linear-time algorithm using hash collisions.\n\n\n\n\n\n","category":"method"},{"location":"lib/mash/#PanGraph.Graphs.Mash.hash-Tuple{UInt64, UInt64}","page":"Mash Implementation","title":"PanGraph.Graphs.Mash.hash","text":"hash(x::UInt64, mask::UInt64)\n\nA transliteration of Jenkin's invertible hash function for 64 bit integers. Bijectively maps any kmer to an integer.\n\n\n\n\n\n","category":"method"},{"location":"lib/mash/#PanGraph.Graphs.Mash.sketch-Tuple{Array{UInt8, N} where N, Int64, Int64, Int64}","page":"Mash Implementation","title":"PanGraph.Graphs.Mash.sketch","text":"sketch(seq::Array{UInt8}, k::Int, w::Int, id::Int)\n\nSketch a linear sequence into a vector of minimizers. k sets the kmer size. w sets the number of contiguous kmers that will be used in the window minimizer comparison. id is a unique integer that corresponds to the sequence. It will be bitpacked into the minimizer position.\n\n\n\n\n\n","category":"method"},{"location":"lib/simulate/#Simulation","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"lib/simulate/#Types","page":"Simulation","title":"Types","text":"","category":"section"},{"location":"lib/simulate/","page":"Simulation","title":"Simulation","text":"Modules = [PanGraph.Simulation]\nOrder = [:type, :constant]","category":"page"},{"location":"lib/simulate/#PanGraph.Simulation.Params","page":"Simulation","title":"PanGraph.Simulation.Params","text":"struct Params\n\tN    :: Int\n\tL    :: Int\n\tσₗ   :: Int\n\trate :: Rates\nend\n\nStore all parameters of a single recombinative Wright-Fisher model. N is the population size. L is the expected genome size of all descendants. σ is the variance of genome size of all descendants. rate is the various rate of evolutionary processes.\n\n\n\n\n\n","category":"type"},{"location":"lib/simulate/#PanGraph.Simulation.Rates","page":"Simulation","title":"PanGraph.Simulation.Rates","text":"struct Rates\n\tsnp :: Float64\n\thgt :: Float64\n\tdel :: Float64\n\tinv :: Float64\nend\n\nStore the rates of evolution of mutation snp, recombination hgt, deletion del, and inversion inv.\n\n\n\n\n\n","category":"type"},{"location":"lib/simulate/#PanGraph.Simulation.Sequence","page":"Simulation","title":"PanGraph.Simulation.Sequence","text":"Sequence = Array{UInt64,1}\n\nA bitpacked array of sequence state. Each UInt64 bits are interpreted as\n\n30 bytes(ancestor) | 30 bytes (location) | 3 bytes (mutation) | 1 byte strand\n\n\n\n\n\n","category":"type"},{"location":"lib/simulate/#Functions","page":"Simulation","title":"Functions","text":"","category":"section"},{"location":"lib/simulate/","page":"Simulation","title":"Simulation","text":"Modules = [PanGraph.Simulation]\nOrder = [:function]","category":"page"},{"location":"lib/simulate/#PanGraph.Simulation.delete!-Tuple{Vector{UInt64}, Int64, Int64}","page":"Simulation","title":"PanGraph.Simulation.delete!","text":"delete!(s::Sequence, from::Int, to::Int)\n\nDelete the interval from:to from sequence s.\n\n\n\n\n\n","category":"method"},{"location":"lib/simulate/#PanGraph.Simulation.insert!-Tuple{Vector{UInt64}, Vector{UInt64}, Int64}","page":"Simulation","title":"PanGraph.Simulation.insert!","text":"insert!(acceptor::Sequence, donor::Sequence, at::Int)\n\nInsert sequence donor into acceptor at locus at.\n\n\n\n\n\n","category":"method"},{"location":"lib/simulate/#PanGraph.Simulation.invert!-Tuple{Vector{UInt64}, Int64, Int64}","page":"Simulation","title":"PanGraph.Simulation.invert!","text":"invert!(s::Sequence, from::Int, to::Int)\n\nReplace the interval from:to of sequence s with its reverse complement.\n\n\n\n\n\n","category":"method"},{"location":"lib/simulate/#PanGraph.Simulation.model-Tuple{PanGraph.Simulation.Params}","page":"Simulation","title":"PanGraph.Simulation.model","text":"model(param::Params)\n\nReturn an evolution function based upon parameters param.\n\n\n\n\n\n","category":"method"},{"location":"lib/simulate/#PanGraph.Simulation.mutate!-Tuple{Vector{UInt64}, Int64}","page":"Simulation","title":"PanGraph.Simulation.mutate!","text":"mutate!(s::Sequence, at::Int)\n\nApply a random mutation to sequence s at locus at.\n\n\n\n\n\n","category":"method"},{"location":"lib/simulate/#PanGraph.Simulation.nucleotide-Tuple{Array{Vector{UInt64}, N} where N, Vector{Vector{UInt8}}}","page":"Simulation","title":"PanGraph.Simulation.nucleotide","text":"nucleotide(sequence::Array{Sequence}, ancestor::Array{Array{UInt8,1},1})\n\nGenerate the set of extant sequences from the ancestral mosiacs sequence and the original sequences ancestor.\n\n\n\n\n\n","category":"method"},{"location":"lib/simulate/#PanGraph.Simulation.pancontig!-Tuple{Vector{UInt64}, Dict{Int64, Array{PanGraph.Graphs.Intervals.Interval, N} where N}}","page":"Simulation","title":"PanGraph.Simulation.pancontig!","text":"pancontig!(s::Sequence, ancestor::Dict{Int,Array{Interval}})\n\nReturn the ancestral tiling imprinted upon Sequence s. Modifies ancestor in place.\n\n\n\n\n\n","category":"method"},{"location":"lib/simulate/#PanGraph.Simulation.pancontigs-Tuple{Array{Vector{UInt64}, N} where N}","page":"Simulation","title":"PanGraph.Simulation.pancontigs","text":"pancontigs(s::Sequence)\n\nReturn the ancestral tiling imprinted upon a set of Sequences isolates.\n\n\n\n\n\n","category":"method"},{"location":"lib/simulate/#PanGraph.Simulation.run-Tuple{Function, Int64, Vector{Vector{UInt8}}}","page":"Simulation","title":"PanGraph.Simulation.run","text":"run(evolve!::Function, time::Int, initial::Array{Array{UInt8,1},1}; graph=false)\n\nThe high level API of the module. Evolves a set of initial sequences initial for time generations using the one-step evolution function evolve! If graph is true, the function will return the pangraph associated to the ancestral tiling.\n\n\n\n\n\n","category":"method"},{"location":"cli/generate/#Generate","page":"Generate","title":"Generate","text":"","category":"section"},{"location":"cli/generate/#Description","page":"Generate","title":"Description","text":"","category":"section"},{"location":"cli/generate/","page":"Generate","title":"Generate","text":"Generate a simulated multiple sequence alignment pangraph.","category":"page"},{"location":"cli/generate/#Options","page":"Generate","title":"Options","text":"","category":"section"},{"location":"cli/generate/","page":"Generate","title":"Generate","text":"Name Type Short Flag Long Flag Description\nMutation rate Float m snp-rate Rate of mutations per site per genome per generation\nHGT rate Float r hgt-rate Rate of horizontal transfer events per genome per generation\nDeletion rate Float d delete-rate Rate of deletion events per genome per generation\nInversion rate Float i invert-rate Rate of inversion events per genome per generation\nGraph output String o output-path Path to location to store simulated pangraph\nTime Integer t time Number of generations to simulate before computing sequences and graph","category":"page"},{"location":"cli/generate/#Arguments","page":"Generate","title":"Arguments","text":"","category":"section"},{"location":"cli/generate/","page":"Generate","title":"Generate","text":"Zero or one fasta file to treat as ancestral sequences. If no file path is given, reads from stdin. In either case, the stream can be optionally gzipped. The number and length of sequences determine the population size.","category":"page"},{"location":"cli/generate/#Output","page":"Generate","title":"Output","text":"","category":"section"},{"location":"cli/generate/","page":"Generate","title":"Generate","text":"Outputs all resultant sequences to standard out. Optionally output the resultant pangraph if a path is supplied by the user.","category":"page"},{"location":"lib/path/#Paths","page":"Paths","title":"Paths","text":"","category":"section"},{"location":"lib/path/#Types","page":"Paths","title":"Types","text":"","category":"section"},{"location":"lib/path/","page":"Paths","title":"Paths","text":"Modules = [PanGraph.Graphs.Paths]\nOrder = [:type, :constant]","category":"page"},{"location":"lib/path/#PanGraph.Graphs.Paths.Link","page":"Paths","title":"PanGraph.Graphs.Paths.Link","text":"Link = NamedTuple{(:block, :strand), Tuple{Block, Bool}}\n\nA shorthand wrapper for an abstract Node object.\n\n\n\n\n\n","category":"type"},{"location":"lib/path/#PanGraph.Graphs.Paths.Path","page":"Paths","title":"PanGraph.Graphs.Paths.Path","text":"mutable struct Path\n\tname     :: String\n\tnode     :: Array{Node{Block}}\n\toffset   :: Union{Int,Nothing}\n\tcircular :: Bool\n\tposition :: Array{Int}\nend\n\nPath is a single genome entry within the pangraph. name stores the unique identifier of the genome. node is an array of Nodes. The concatenation of all Nodes recapitulates the original sequence. offset is the circular shift that must be applied to the concatenation to retain the original starting positition. It is nothing if the Path is linear. circular is true only if the path should be considered circular, i.e. the last node is implictly connected to the first node. position represents the array of breakpoints each node corresponds to.\n\n\n\n\n\n","category":"type"},{"location":"lib/path/#PanGraph.Graphs.Paths.Path-Tuple{String, PanGraph.Graphs.Nodes.Node{PanGraph.Graphs.Blocks.Block}}","page":"Paths","title":"PanGraph.Graphs.Paths.Path","text":"Path(name::String,node::Node{Block};circular::Bool=false)\n\nReturn a new Path structure obtained from a single node and name name.  By default will be interpreted as a linear path.\n\n\n\n\n\n","category":"method"},{"location":"lib/path/#Functions","page":"Paths","title":"Functions","text":"","category":"section"},{"location":"lib/path/","page":"Paths","title":"Paths","text":"Modules = [PanGraph.Graphs.Paths]\nOrder = [:function]","category":"page"},{"location":"lib/path/#Base.length-Tuple{PanGraph.Graphs.Paths.Path}","page":"Paths","title":"Base.length","text":"length(p::Path)\n\nReturn the number of nodes associated to Path p.\n\n\n\n\n\n","category":"method"},{"location":"lib/path/#Base.replace!-Tuple{PanGraph.Graphs.Paths.Path, Array{NamedTuple{(:block, :strand), Tuple{PanGraph.Graphs.Blocks.Block, Bool}}, N} where N, PanGraph.Graphs.Blocks.Block}","page":"Paths","title":"Base.replace!","text":"replace!(p::Path, old::Array{Link}, new::Block)\n\nReplace all instances of oriented Block list old with the single block new. Operates on Path p in place.\n\n\n\n\n\n","category":"method"},{"location":"lib/path/#Base.replace!-Tuple{PanGraph.Graphs.Paths.Path, PanGraph.Graphs.Blocks.Block, Array{PanGraph.Graphs.Blocks.Block, N} where N, Bool}","page":"Paths","title":"Base.replace!","text":"replace!(p::Path, old::Block, new::Array{Block}, orientation::Bool)\n\nReplace all instances of Block old with the array of blocks new. Operates on Path p in place. orientation is the relative orientation assumed between old and new, i.e. if it is false, new is assumed to be the reverse complement of old.\n\n\n\n\n\n","category":"method"},{"location":"lib/path/#PanGraph.Graphs.Paths.count_isolates-Tuple{Any}","page":"Paths","title":"PanGraph.Graphs.Paths.count_isolates","text":"count_isolates(paths)\n\nReturn the number of times each isolate within paths appears in each block.\n\n\n\n\n\n","category":"method"},{"location":"lib/path/#PanGraph.Graphs.Paths.positions!-Tuple{PanGraph.Graphs.Paths.Path}","page":"Paths","title":"PanGraph.Graphs.Paths.positions!","text":"positions!(p::Path)\n\nCompute the positions of each breakpoint represented by a node in Path p. Modifies p in place.\n\n\n\n\n\n","category":"method"},{"location":"lib/path/#PanGraph.Graphs.sequence-Tuple{PanGraph.Graphs.Paths.Path}","page":"Paths","title":"PanGraph.Graphs.sequence","text":"sequence(p::Path; shift=true)\n\nReturn the reconstructed sequence of Path p. If shift is false, the circular offset will be ignored.\n\n\n\n\n\n","category":"method"},{"location":"lib/graph/#Graphs","page":"Graphs","title":"Graphs","text":"","category":"section"},{"location":"lib/graph/","page":"Graphs","title":"Graphs","text":"CurrentModule = PanGraph","category":"page"},{"location":"lib/graph/#Types","page":"Graphs","title":"Types","text":"","category":"section"},{"location":"lib/graph/","page":"Graphs","title":"Graphs","text":"Modules = [Graphs]\nOrder = [:type, :constant]","category":"page"},{"location":"lib/graph/#PanGraph.Graphs.DelMap","page":"Graphs","title":"PanGraph.Graphs.DelMap","text":"DelMap = Dict{Int,Int}\n\nA sparse array of deletion events relative to a consensus. The key is the locus (inclusive) of the deletion; the value is the length.\n\n\n\n\n\n","category":"type"},{"location":"lib/graph/#PanGraph.Graphs.Graph","page":"Graphs","title":"PanGraph.Graphs.Graph","text":"struct Graph\n    block    :: Dict{String, Block}\n    sequence :: Dict{String, Path}\nend\n\nRepresentation of a multiple sequence alignment. Alignments of homologous sequences are stored as blocks. A genome is stored as a path, i.e. a list of blocks.\n\n\n\n\n\n","category":"type"},{"location":"lib/graph/#PanGraph.Graphs.Graph-Tuple{String, Array{UInt8, N} where N}","page":"Graphs","title":"PanGraph.Graphs.Graph","text":"Graph(name::String, sequence::Array{UInt8}; circular=false)\n\nCreates a singleton graph from sequence. name is assumed to be a unique identifier. If circular is unspecified, the sequence is assumed to be linear.\n\n\n\n\n\n","category":"method"},{"location":"lib/graph/#PanGraph.Graphs.InsMap","page":"Graphs","title":"PanGraph.Graphs.InsMap","text":"InsMap = Dict{Tuple{Int,Int},Array{UInt8,1}}\n\nA sparse array of insertion sequences relative to a consensus. The key is the (locus(after),offset) of the insertion; the value is the sequence.\n\n\n\n\n\n","category":"type"},{"location":"lib/graph/#PanGraph.Graphs.SNPMap","page":"Graphs","title":"PanGraph.Graphs.SNPMap","text":"SNPMap = Dict{Int,UInt8}\n\nA sparse array of single nucleotide polymorphisms relative to a consensus. The key is the locus of the mutation; the value is the modified nucleotide.\n\n\n\n\n\n","category":"type"},{"location":"lib/graph/#Functions","page":"Graphs","title":"Functions","text":"","category":"section"},{"location":"lib/graph/","page":"Graphs","title":"Graphs","text":"Modules = [Graphs]\nOrder = [:function]","category":"page"},{"location":"lib/graph/#PanGraph.Graphs.detransitive!-Tuple{PanGraph.Graphs.Graph}","page":"Graphs","title":"PanGraph.Graphs.detransitive!","text":"detransitive!(G::Graph)\n\nFind and remove all transitive edges within the given graph. A transitive chain of edges is defined to be unambiguous: all sequences must enter on one edge and leave on another. Thus, this will not perform paralog splitting.\n\n\n\n\n\n","category":"method"},{"location":"lib/graph/#PanGraph.Graphs.finalize!-Tuple{Any}","page":"Graphs","title":"PanGraph.Graphs.finalize!","text":"finalize!(G::Graph)\n\nCompute the position of the breakpoints for each homologous alignment across all sequences within Graph G. Intended to be ran after multiple sequence alignment is complete\n\n\n\n\n\n","category":"method"},{"location":"lib/graph/#PanGraph.Graphs.graphs-Tuple{IO}","page":"Graphs","title":"PanGraph.Graphs.graphs","text":"graphs(io::IO; circular=false)\n\nParse a fasta file from stream io and return an array of singleton graphs. If circular is unspecified, all genomes are assumed to be linear.\n\n\n\n\n\n","category":"method"},{"location":"lib/graph/#PanGraph.Graphs.keeponly!-Tuple{PanGraph.Graphs.Graph, Vararg{String, N} where N}","page":"Graphs","title":"PanGraph.Graphs.keeponly!","text":"keeponly!(G::Graph, names::String...)\n\nRemove all sequences from graph G that are passed as variadic parameters names. This will marginalize a graph, i.e. return the subgraph that contains only isolates contained in names\n\n\n\n\n\n","category":"method"},{"location":"lib/graph/#PanGraph.Graphs.marshal_fasta-Tuple{IO, PanGraph.Graphs.Graph}","page":"Graphs","title":"PanGraph.Graphs.marshal_fasta","text":"marshal_fasta(io::IO, G::Graph; opt=nothing)\n\nSerialize graph G as a fasta format output stream io. Importantly, this will only serialize the consensus sequences for each block and not the full multiple sequence alignment.\n\nopt is currently ignored. It is kept for signature uniformity for other marshal functions\n\n\n\n\n\n","category":"method"},{"location":"lib/graph/#PanGraph.Graphs.marshal_json-Tuple{IO, PanGraph.Graphs.Graph}","page":"Graphs","title":"PanGraph.Graphs.marshal_json","text":"marshal_json(io::IO, G::Graph; opt=nothing)\n\nSerialize graph G as a json format output stream io. This is the main storage/exported format for PanGraph. Currently it is the only format that can reconstruct an in-memory pangraph.\n\nopt is currently ignored. It is kept for signature uniformity for other marshal functions\n\n\n\n\n\n","category":"method"},{"location":"lib/graph/#PanGraph.Graphs.prune!-Tuple{PanGraph.Graphs.Graph}","page":"Graphs","title":"PanGraph.Graphs.prune!","text":"prune!(G::Graph)\n\nRemove all blocks from graph G that are not currently used by any extant sequence. Internal function used during guide tree alignment.\n\n\n\n\n\n","category":"method"},{"location":"lib/graph/#PanGraph.Graphs.realign!-Tuple{PanGraph.Graphs.Graph}","page":"Graphs","title":"PanGraph.Graphs.realign!","text":"realign!(G::Graph; accept)\n\nRealign blocks contained within graph G. Usage of this function requires MAFFT to be on the system PATH accept should be a function that returns true on blocks you wish to realign. By default, all blocks are realigned.\n\n\n\n\n\n","category":"method"},{"location":"lib/graph/#PanGraph.Graphs.sequence-Tuple{PanGraph.Graphs.Graph, AbstractString}","page":"Graphs","title":"PanGraph.Graphs.sequence","text":"sequence(G::Graph, name::String)\n\nReturn the sequence corresponding to genome name within graph G\n\n\n\n\n\n","category":"method"},{"location":"lib/graph/#PanGraph.Graphs.sequence-Tuple{PanGraph.Graphs.Graph}","page":"Graphs","title":"PanGraph.Graphs.sequence","text":"sequence(G::Graph)\n\nReturn all pairs of name => sequence encoded within graph G\n\n\n\n\n\n","category":"method"},{"location":"lib/graph/#PanGraph.Graphs.test","page":"Graphs","title":"PanGraph.Graphs.test","text":"test(path)\n\nAlign all sequences found in the fasta file at path into a pangraph. Verifies that after the alignment is complete, all sequences are correctly reconstructed\n\n\n\n\n\n","category":"function"},{"location":"lib/graph/#PanGraph.Graphs.unmarshal-Tuple{Any}","page":"Graphs","title":"PanGraph.Graphs.unmarshal","text":"unmarshal(io::IO)\n\nDeserialize the json formatted input stream io into a Graph data structure. Return a Graph type.\n\n\n\n\n\n","category":"method"},{"location":"cli/polish/#Polish","page":"Polish","title":"Polish","text":"","category":"section"},{"location":"cli/polish/#Description","page":"Polish","title":"Description","text":"","category":"section"},{"location":"cli/polish/","page":"Polish","title":"Polish","text":"Realigns blocks of a multiple sequence alignment pangraph with an external multiple sequence alignment tool.","category":"page"},{"location":"cli/polish/#Options","page":"Polish","title":"Options","text":"","category":"section"},{"location":"cli/polish/","page":"Polish","title":"Polish","text":"Name Type Short Flag Long Flag Description\nMaximum Length Integer l length cutoff above which the block is not realigned externally","category":"page"},{"location":"cli/polish/#Arguments","page":"Polish","title":"Arguments","text":"","category":"section"},{"location":"cli/polish/","page":"Polish","title":"Polish","text":"Zero or one pangraph file which must be formatted as a JSON. If no file path is given, reads from stdin. In either case, the stream can be optionally gzipped.","category":"page"},{"location":"cli/polish/#Output","page":"Polish","title":"Output","text":"","category":"section"},{"location":"cli/polish/","page":"Polish","title":"Polish","text":"Outputs the polished pangraph to stdout.","category":"page"},{"location":"lib/utility/#Utility","page":"Utility","title":"Utility","text":"","category":"section"},{"location":"lib/utility/#Types","page":"Utility","title":"Types","text":"","category":"section"},{"location":"lib/utility/","page":"Utility","title":"Utility","text":"Modules = [PanGraph.Graphs.Utility]\nOrder = [:type, :constant]","category":"page"},{"location":"lib/utility/#PanGraph.Graphs.Utility.Alignment","page":"Utility","title":"PanGraph.Graphs.Utility.Alignment","text":"mutable struct Alignment{T <: Union{String,Nothing,Array{Tuple{Int,Char}}}}\n\tqry::Hit\n\tref::Hit\n\tmatches::Int\n\tlength::Int\n\tquality::Int\n\torientation::Bool\n\tcigar::T\n\tdivergence::Union{Float64,Nothing}\n\talign::Union{Float64,Nothing}\nend\n\nAlignment is a pairwise homologous alignment between two sequences.\n\n\n\n\n\n","category":"type"},{"location":"lib/utility/#PanGraph.Graphs.Utility.Hit","page":"Utility","title":"PanGraph.Graphs.Utility.Hit","text":"mutable struct Hit\n\tname::String\n\tlength::Int\n\tstart::Int\n\tstop::Int\n\tseq::Maybe{Array{UInt8,1}}\nend\n\nHit is one side of a pairwise alignment between homologous sequences.\n\n\n\n\n\n","category":"type"},{"location":"lib/utility/#PanGraph.Graphs.Utility.Record","page":"Utility","title":"PanGraph.Graphs.Utility.Record","text":"struct Record\n\tseq::Array{UInt8}\n\tname::String\n\tmeta::String\nend\n\nA record obtained when parsing a single entry of a FASTA file.\n\n\n\n\n\n","category":"type"},{"location":"lib/utility/#PanGraph.Graphs.Utility.Score","page":"Utility","title":"PanGraph.Graphs.Utility.Score","text":"struct Score <: AbstractArray{Float64,2}\n\trows::Int\n\tcols::Int\n\tband::NamedTuple{(:lower, :upper)}\n\tdata::Array{Float64}\n\toffset::Array{Int}\n\tstarts::Array{Int}\n\tstops::Array{Int}\nend\n\nStore information about a banded pairwise alignment.\n\n\n\n\n\n","category":"type"},{"location":"lib/utility/#PanGraph.Graphs.Utility.cost","page":"Utility","title":"PanGraph.Graphs.Utility.cost","text":"cost = (\n\topen   = -6.0,\n\textend = -1.0,\n\tband   = (\n\t\tlower = Inf,\n\t\tupper = Inf,\n\t),\n\tgap    = k -> k == 0 ? 0 : cost.open + cost.extend*(k-1),\n\tmatch  = (c₁, c₂) -> 6.0*(c₁ == c₂) - 3.0,\n)\n\ncost are the default dynamic alignment parameters used.\n\n\n\n\n\n","category":"constant"},{"location":"lib/utility/#Functions","page":"Utility","title":"Functions","text":"","category":"section"},{"location":"lib/utility/","page":"Utility","title":"Utility","text":"Modules = [PanGraph.Graphs.Utility]\nOrder = [:function]","category":"page"},{"location":"lib/utility/#PanGraph.Graphs.Utility.align-Tuple{Array{UInt8, N} where N, Array{UInt8, N} where N, Any}","page":"Utility","title":"PanGraph.Graphs.Utility.align","text":"align(seq₁::Array{UInt8}, seq₂::Array{UInt8}, cost::Score)\n\nPerform a pairwise alignment using Needleman-Wunsch style dynamic programming between seq₁ and seq₂ given cost. The cost is defined by the Score structure.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#PanGraph.Graphs.Utility.cigar-Tuple{Array{UInt8, N} where N, Array{UInt8, N} where N}","page":"Utility","title":"PanGraph.Graphs.Utility.cigar","text":"cigar(seq₁::Array{UInt8}, seq₂::Array{UInt8})\n\nGiven two sequences, seq₁ and seq₂, perform a pairwise banded alignment and return the cigar string of alignment.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#PanGraph.Graphs.Utility.columns-Tuple{Any}","page":"Utility","title":"PanGraph.Graphs.Utility.columns","text":"columns(s; nc=80)\n\nPartition string s into an array of strings such that no string is longer than nc characters.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#PanGraph.Graphs.Utility.enforce_cutoff!-Tuple{PanGraph.Graphs.Utility.Alignment, Any}","page":"Utility","title":"PanGraph.Graphs.Utility.enforce_cutoff!","text":"enforce_cutoff!(a::Alignment, χ)\n\nEnsure that the alignment a does not have insertion or deletion segments larger than χ. Return the list of segments created by parsing the alignment such that all segments are larger than χ.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#PanGraph.Graphs.Utility.hamming_align-Tuple{Vector{UInt8}, Vector{UInt8}}","page":"Utility","title":"PanGraph.Graphs.Utility.hamming_align","text":"hamming_align(qry::Array{UInt8,1}, ref::Array{UInt8,1})\n\nPerform a simple alignment of qry to ref by minimizing hamming distance. Useful for fast, approximate alignments of small sequences.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#PanGraph.Graphs.Utility.random_id-Tuple{}","page":"Utility","title":"PanGraph.Graphs.Utility.random_id","text":"random_id(;len=10, alphabet=UInt8[])\n\nGenerate a random string of length len drawn from letters in alphabet.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#PanGraph.Graphs.Utility.read_fasta-Tuple{IO}","page":"Utility","title":"PanGraph.Graphs.Utility.read_fasta","text":"read_fasta(io::IO)\n\nParse a FASTA file from IO stream io. Return an iterator over all records.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#PanGraph.Graphs.Utility.read_paf-Tuple{IO}","page":"Utility","title":"PanGraph.Graphs.Utility.read_paf","text":"read_paf(io::IO)\n\nParse a PAF file from IO stream io. Return an iterator over all pairwise alignments.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#PanGraph.Graphs.Utility.uncigar-Tuple{String}","page":"Utility","title":"PanGraph.Graphs.Utility.uncigar","text":"uncigar(cg::String)\n\nReturn an interator over intervals of alignment defined by cigar string cg.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#PanGraph.Graphs.Utility.write_fasta-Tuple{IO, Any, Any}","page":"Utility","title":"PanGraph.Graphs.Utility.write_fasta","text":"write_fasta(io::IO, name, seq)\n\nOutput a single FASTA record with sequence seq and name name to IO stream io.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#PanGraph.Graphs.reverse_complement!-Tuple{PanGraph.Graphs.Utility.Hit}","page":"Utility","title":"PanGraph.Graphs.reverse_complement!","text":"reverse_complement!(hit::Hit)\n\nReverse complement the qry of Hit in place.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#PanGraph.Graphs.reverse_complement-Tuple{Array{UInt8, N} where N}","page":"Utility","title":"PanGraph.Graphs.reverse_complement","text":"reverse_complement(seq::Array{UInt8})\n\nReturn a newly allocated sequence array that is the reverse complement of seq.\n\n\n\n\n\n","category":"method"},{"location":"cli/marginalize/#Marginalize","page":"Marginalize","title":"Marginalize","text":"","category":"section"},{"location":"cli/marginalize/#Description","page":"Marginalize","title":"Description","text":"","category":"section"},{"location":"cli/marginalize/","page":"Marginalize","title":"Marginalize","text":"Compute all pairwise marginalizations of a multiple sequence alignment pangraph.","category":"page"},{"location":"cli/marginalize/#Options","page":"Marginalize","title":"Options","text":"","category":"section"},{"location":"cli/marginalize/","page":"Marginalize","title":"Marginalize","text":"Name Type Short Flag Long Flag Description\nOutput path String o output-path Path to direcotry where output files will be stored\nReduce paralogs Boolean r reduce-paralog Collapses coparallel paths through duplicated blocks.","category":"page"},{"location":"cli/marginalize/#Arguments","page":"Marginalize","title":"Arguments","text":"","category":"section"},{"location":"cli/marginalize/","page":"Marginalize","title":"Marginalize","text":"Zero or one pangraph file which must be formatted as a JSON. If no file path is given, reads from stdin. In either case, the stream can be optionally gzipped.","category":"page"},{"location":"cli/marginalize/#Output","page":"Marginalize","title":"Output","text":"","category":"section"},{"location":"cli/marginalize/","page":"Marginalize","title":"Marginalize","text":"Outputs all pairwise graphs to the directory at the user-supplied path.","category":"page"},{"location":"lib/align/#Alignment","page":"Alignment","title":"Alignment","text":"","category":"section"},{"location":"lib/align/#Types","page":"Alignment","title":"Types","text":"","category":"section"},{"location":"lib/align/","page":"Alignment","title":"Alignment","text":"Modules = [PanGraph.Graphs.Align]\nOrder = [:type, :constant]","category":"page"},{"location":"lib/align/#PanGraph.Graphs.Align.Clade","page":"Alignment","title":"PanGraph.Graphs.Align.Clade","text":"mutable struct Clade\n\tname   :: String\n\tparent :: Union{Clade,Nothing}\n\tleft   :: Union{Clade,Nothing}\n\tright  :: Union{Clade,Nothing}\n\tgraph  :: Channel{Graph}\nend\n\nClade is a node (internal or leaf) of a binary guide tree used to order pairwise alignments associated to a multiple genome alignment in progress. name is only non-empty for leaf nodes. parent is nothing for the root node. graph is a 0-sized channel that is used as a message passing primitive in alignment.\n\n\n\n\n\n","category":"type"},{"location":"lib/align/#PanGraph.Graphs.Align.Clade-Tuple{Any, Any}","page":"Alignment","title":"PanGraph.Graphs.Align.Clade","text":"Clade(distance, names; algo=:nj)\n\nGenerate a tree from a matrix of pairwise distances distance. The names of leafs are given by an array of strings names. algo dictates the algorithm used to transform the distance matrix into a tree. Currently on neighbor joining (:nj) is supported.\n\n\n\n\n\n","category":"method"},{"location":"lib/align/#PanGraph.Graphs.Align.Clade-Tuple{Any}","page":"Alignment","title":"PanGraph.Graphs.Align.Clade","text":"Clade(name)\n\nGenerate an empty, disconnected clade with name name.\n\n\n\n\n\n","category":"method"},{"location":"lib/align/#PanGraph.Graphs.Align.Clade-Tuple{PanGraph.Graphs.Align.Clade, PanGraph.Graphs.Align.Clade}","page":"Alignment","title":"PanGraph.Graphs.Align.Clade","text":"Clade(left::Clade, right::Clade)\n\nGenerate an nameless clade with left and right children.\n\n\n\n\n\n","category":"method"},{"location":"lib/align/#PanGraph.Graphs.Align.Clade-Tuple{}","page":"Alignment","title":"PanGraph.Graphs.Align.Clade","text":"Clade()\n\nGenerate an empty, disconnected clade.\n\n\n\n\n\n","category":"method"},{"location":"lib/align/#Functions","page":"Alignment","title":"Functions","text":"","category":"section"},{"location":"lib/align/","page":"Alignment","title":"Alignment","text":"Modules = [PanGraph.Graphs.Align]\nOrder = [:function]","category":"page"},{"location":"lib/align/#PanGraph.Graphs.Align.align-Tuple{Vararg{PanGraph.Graphs.Graph, N} where N}","page":"Alignment","title":"PanGraph.Graphs.Align.align","text":"align(G::Graph...; compare=Mash.distance, energy=(hit)->(-Inf), minblock=100)\n\nAlign graph G₁ to itself by looking for homology between blocks. Multithreaded by default. This is usually the function you want.\n\nenergy is to be a function that takes an alignment between two blocks and produces a score. The lower the score, the better the alignment. Only negative energies are considered.\n\nminblock is the minimum size block that will be produced from the algorithm. maxiter is maximum number of duplications that will be considered during this alignment.\n\ncompare is the function to be used to generate pairwise distances that generate the internal guide tree.\n\n\n\n\n\n","category":"method"},{"location":"lib/align/#PanGraph.Graphs.Align.align_pair-Tuple{PanGraph.Graphs.Graph, PanGraph.Graphs.Graph, Function, Int64, Function, Bool}","page":"Alignment","title":"PanGraph.Graphs.Align.align_pair","text":"align_pair(G₁::Graph, G₂::Graph, energy::Function, minblock::Int, verify::Function, verbose::Bool; maxiter=100)\n\nAlign graph G₁ to graph G₂ by looking for homology between consensus sequences of blocks. This is a low-level function.\n\nenergy is to be a function that takes an alignment between two blocks and produces a score. The lower the score, the better the alignment. Only negative energies are considered.\n\nminblock is the minimum size block that will be produced from the algorithm. maxiter is maximum number of duplications that will be considered during this alignment.\n\n\n\n\n\n","category":"method"},{"location":"lib/align/#PanGraph.Graphs.Align.align_self-Tuple{PanGraph.Graphs.Graph, Function, Int64, Function, Bool}","page":"Alignment","title":"PanGraph.Graphs.Align.align_self","text":"align_self(G₁::Graph, energy::Function, minblock::Int, verify::Function, verbose::Bool; maxiter=100)\n\nAlign graph G₁ to itself by looking for homology between blocks. This is a low-level function.\n\nenergy is to be a function that takes an alignment between two blocks and produces a score. The lower the score, the better the alignment. Only negative energies are considered.\n\nminblock is the minimum size block that will be produced from the algorithm. maxiter is maximum number of duplications that will be considered during this alignment.\n\n\n\n\n\n","category":"method"},{"location":"lib/align/#PanGraph.Graphs.Align.isleaf-Tuple{PanGraph.Graphs.Align.Clade}","page":"Alignment","title":"PanGraph.Graphs.Align.isleaf","text":"isleaf(c::Clade)\n\nReturn if Clade c is a terminal node, i.e. a leaf.\n\n\n\n\n\n","category":"method"},{"location":"lib/align/#PanGraph.Graphs.Align.leaves-Tuple{PanGraph.Graphs.Align.Clade}","page":"Alignment","title":"PanGraph.Graphs.Align.leaves","text":"leaves(root::Clade)\n\nReturn all terminal nodes that have root as their common ancestor.\n\n\n\n\n\n","category":"method"},{"location":"lib/align/#PanGraph.Graphs.Align.nj-Tuple{Any, Any}","page":"Alignment","title":"PanGraph.Graphs.Align.nj","text":"nj(distance, names)\n\nLower-level function. Generate a tree from a matrix of pairwise distances distance. The names of leafs are given by an array of strings names. Uses neighbor joining.\n\n\n\n\n\n","category":"method"},{"location":"lib/align/#PanGraph.Graphs.Align.ordering-Tuple{Any, Vararg{Any, N} where N}","page":"Alignment","title":"PanGraph.Graphs.Align.ordering","text":"ordering(compare, Gs...)\n\nReturn a guide tree based upon distances computed from a collection of graphs Gs, using method compare. The signature of compare is expected to be compare(G::Graphs....) -> distance, names. Graphs Gs... are expected to be singleton graphs.\n\n\n\n\n\n","category":"method"},{"location":"lib/align/#PanGraph.Graphs.Align.postorder-Tuple{PanGraph.Graphs.Align.Clade}","page":"Alignment","title":"PanGraph.Graphs.Align.postorder","text":"postorder(root::Clade)\n\nReturn an postorder iterator over descendents of root.\n\n\n\n\n\n","category":"method"},{"location":"lib/align/#PanGraph.Graphs.Align.preorder-Tuple{PanGraph.Graphs.Align.Clade}","page":"Alignment","title":"PanGraph.Graphs.Align.preorder","text":"preorder(root::Clade)\n\nReturn an preorder iterator over descendents of root.\n\n\n\n\n\n","category":"method"},{"location":"lib/minimap/#Minimap2-Wrapper","page":"Minimap2 Wrapper","title":"Minimap2 Wrapper","text":"","category":"section"},{"location":"lib/minimap/#Types","page":"Minimap2 Wrapper","title":"Types","text":"","category":"section"},{"location":"lib/minimap/","page":"Minimap2 Wrapper","title":"Minimap2 Wrapper","text":"Modules = [PanGraph.Graphs.Minimap]\nOrder = [:type, :constant]","category":"page"},{"location":"lib/minimap/#PanGraph.Graphs.Minimap.Buffer","page":"Minimap2 Wrapper","title":"PanGraph.Graphs.Minimap.Buffer","text":"struct Buffer\n\thandle :: Ptr{Cvoid}\nend\n\nStore the untyped address to a minimap2 sequence buffer (working space).\n\n\n\n\n\n","category":"type"},{"location":"lib/minimap/#PanGraph.Graphs.Minimap.Extra","page":"Minimap2 Wrapper","title":"PanGraph.Graphs.Minimap.Extra","text":"struct Extra\n\tcapacity :: UInt32\n\tdp_score :: Int32\n\tdp_max   :: Int32\n\tdp_max2  :: Int32\n\tpacked   :: UInt32 # n_ambi (30 bits) / strand (2 bits)\n\tn_cigar  :: UInt32\n\tcigar UInt32[] (variable length array)\nend\n\nCopied from minimap2.h. See mmextrat.\n\n\n\n\n\n","category":"type"},{"location":"lib/minimap/#PanGraph.Graphs.Minimap.Index","page":"Minimap2 Wrapper","title":"PanGraph.Graphs.Minimap.Index","text":"struct Index\n\thandle :: Ptr{Cvoid}\nend\n\nStore the untyped address to a minimap2 sequence index (set of minimizers).\n\n\n\n\n\n","category":"type"},{"location":"lib/minimap/#PanGraph.Graphs.Minimap.IndexOptions","page":"Minimap2 Wrapper","title":"PanGraph.Graphs.Minimap.IndexOptions","text":"struct IndexOptions\n\tk    :: Cshort\n\tw    :: Cshort\n\tflag :: Cshort\n\tbucket_bits :: Cshort\n\tmini_batch_size :: Int64\n\tbatch_size :: UInt64\n\n\tIndexOptions() = new()\nend\n\nCopied from minimap2.h. See mmidxoptt.\n\n\n\n\n\n","category":"type"},{"location":"lib/minimap/#PanGraph.Graphs.Minimap.MapOptions","page":"Minimap2 Wrapper","title":"PanGraph.Graphs.Minimap.MapOptions","text":"mutable struct MapOptions\n\tflag :: Int64\n\tseed :: Cint\n\tsdust_thres :: Cint\n\n\tmax_qlen :: Cint\n\n\tbw :: Cint; bw_long :: Cint\n\tmax_gap :: Cint; max_gap_ref :: Cint \n\tmax_frag_len :: Cint\n\tmax_chain_skip :: Cint; max_chain_iter :: Cint\n\tmin_cnt :: Cint\n\tmin_chain_score :: Cint\n\tchain_gap_scale :: Cfloat\n\trmq_size_cap :: Cint; rmq_inner_dist :: Cint\n\trmq_rescue_size :: Cint\n\trmq_rescue_ratio :: Cfloat\n\n\tmask_level :: Cfloat\n\tmask_len :: Cint\n\tpri_ratio :: Cfloat\n\tbest_n :: Cint\n\n\talt_drop :: Cfloat\n\n\ta :: Cint; b :: Cint; q :: Cint; e :: Cint; q2 :: Cint; e2 :: Cint\n\tsc_ambi :: Cint\n\tnoncan :: Cint \n\tjunc_bonus :: Cint\n\tzdrop :: Cint; zdrop_inv :: Cint\n\tend_bonus :: Cint\n\tmin_dp_max :: Cint\n\tmin_ksw_len :: Cint\n\tanchor_ext_len :: Cint; anchor_ext_shift :: Cint\n\tmax_clip_ratio :: Cfloat\n\n\trank_min_len :: Cint\n\trank_frac :: Cfloat\n\n\tpe_ori :: Cint; pe_bonus :: Cint\n\n\tmid_occ_frac :: Cfloat\n\tmin_mid_occ :: Int32; max_mid_occ :: Int32\n\tmid_occ :: Int32\n\tmax_occ :: Int32; max_max_occ :: Int32; occ_dist :: Int32;\n\tmini_batch_size :: Int64\n\tmax_sw_mat :: Int64\n\tcap_kalloc :: Int64\n\n\tsplit_prefix :: Cstring\nend\n\nCopied from minimap2.h. See mmmapoptt.\n\n\n\n\n\n","category":"type"},{"location":"lib/minimap/#PanGraph.Graphs.Minimap.PanContigs","page":"Minimap2 Wrapper","title":"PanGraph.Graphs.Minimap.PanContigs","text":"struct PanContigs\n\tname     :: T\n\tsequence :: T\nend\n\nA synonym for a consensus sequence of Block.\n\n\n\n\n\n","category":"type"},{"location":"lib/minimap/#PanGraph.Graphs.Minimap.Record","page":"Minimap2 Wrapper","title":"PanGraph.Graphs.Minimap.Record","text":"struct Record\n\tid :: Int32; cnt :: Int32; rid :: Int32; score :: Int32\n\tqs :: Int32; qe  :: Int32; rs  :: Int32; re :: Int32\n\n\tparent :: Int32; subsc :: Int32\n\n\tas     :: Int32\n\tmlen   :: Int32; blen :: Int32\n\tnsub   :: Int32;\n\tscore0 :: Int32;\n\n\tpack :: UInt32 # mapq(8) ; split(2); rev(1); inv(1); sam_pri(1); proper_frag(1); pe_thru(1); seg_split(1); seg_id(8); split_inv(1); is_alt(1); dummy(6)\n\thash :: UInt32\n\tdiv  :: Cfloat\n\tp    :: Ptr{Extra}\nend\n\nCopied from minimap2.h. See mmreg1t.\n\n\n\n\n\n","category":"type"},{"location":"lib/minimap/#Functions","page":"Minimap2 Wrapper","title":"Functions","text":"","category":"section"},{"location":"lib/minimap/","page":"Minimap2 Wrapper","title":"Minimap2 Wrapper","text":"Modules = [PanGraph.Graphs.Minimap]\nOrder = [:function]","category":"page"},{"location":"lib/minimap/#PanGraph.Graphs.Minimap.align-Tuple{PanGraph.Graphs.Minimap.PanContigs, PanGraph.Graphs.Minimap.PanContigs, Int64}","page":"Minimap2 Wrapper","title":"PanGraph.Graphs.Minimap.align","text":"align(ref::PanContigs, qry::PanContigs, minblock::Int)\n\nCall into minimap to align the set of blocks qry to blocks ref. This is probably the function you want. If you call into the function specifically, all memory management is taken care of for you.\n\n\n\n\n\n","category":"method"},{"location":"lib/minimap/#PanGraph.Graphs.Minimap.freebuffer-Tuple{PanGraph.Graphs.Minimap.Buffer}","page":"Minimap2 Wrapper","title":"PanGraph.Graphs.Minimap.freebuffer","text":"freebuffer()\n\nFree memory associated to an opaque handle thread buffer\n\n\n\n\n\n","category":"method"},{"location":"lib/minimap/#PanGraph.Graphs.Minimap.freeindex-Tuple{PanGraph.Graphs.Minimap.Index}","page":"Minimap2 Wrapper","title":"PanGraph.Graphs.Minimap.freeindex","text":"freeindex()\n\nFree memory associated to an opaque handle to a sequence index.\n\n\n\n\n\n","category":"method"},{"location":"lib/minimap/#PanGraph.Graphs.Minimap.makebuffer-Tuple{}","page":"Minimap2 Wrapper","title":"PanGraph.Graphs.Minimap.makebuffer","text":"makebuffer()\n\nReturn an opaque handle thread buffer\n\n\n\n\n\n","category":"method"},{"location":"lib/minimap/#PanGraph.Graphs.Minimap.makeindex-NTuple{4, Any}","page":"Minimap2 Wrapper","title":"PanGraph.Graphs.Minimap.makeindex","text":"makeindex(w, k, names, sequence; bucketbits::Int=14)\n\nGiven a window size w and kmer length k, return a handle to a minimizer index for sequences sequence.\n\n\n\n\n\n","category":"method"},{"location":"cli/export/#Export","page":"Export","title":"Export","text":"","category":"section"},{"location":"cli/export/#Description","page":"Export","title":"Description","text":"","category":"section"},{"location":"cli/export/","page":"Export","title":"Export","text":"Export a pangraph to a chosen file format(s)","category":"page"},{"location":"cli/export/#Options","page":"Export","title":"Options","text":"","category":"section"},{"location":"cli/export/","page":"Export","title":"Export","text":"Name Type Short Flag Long Flag Description\nEdge minimum length Integer ell edge-minimum-length blocks below this length cutoff will be ignored for edges in graph\nEdge maximum length Integer elu edge-maximum-length blocks above this length cutoff will be ignored for edges in graph\nEdge minimum depth Integer edl edge-minimum-depth blocks below this depth cutoff will be ignored for edges in graph\nEdge maximum depth Integer edu edge-maximum-depth blocks above this depth cutoff will be ignored for edges in graph\nMinimum length Integer ll minimum-length blocks below this length cutoff will be ignored for export\nMaximum length Integer lu maximum-length blocks above this length cutoff will be ignored for export\nMinimum depth Integer dl minimum-depth blocks below this depth cutoff will be ignored for export\nMaximum depth Integer du maximum-depth blocks above this depth cutoff will be ignored for export\nOutput directory String o output-directory path to directory where output will be stored\nPrefix String p prefix basename of exported files\nGFA Boolean ng no-export-gfa toggles whether pangraph is exported as GFA.\nPanX Boolean px export-panX toggles whether pangraph is exported to panX visualization compatible format.","category":"page"},{"location":"cli/export/#Arguments","page":"Export","title":"Arguments","text":"","category":"section"},{"location":"cli/export/","page":"Export","title":"Export","text":"Zero or one pangraph file which must be formatted as a JSON. If no file path is given, reads from stdin. In either case, the stream can be optionally gzipped.","category":"page"},{"location":"cli/export/#Output","page":"Export","title":"Output","text":"","category":"section"},{"location":"cli/export/","page":"Export","title":"Export","text":"Outputs the constructed pangraph to the selected formats at the user-supplied paths.","category":"page"},{"location":"#PanGraph","page":"Home","title":"PanGraph","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A fast, self-contained Julia library and command line tool suite that aligns multiple genomes simultaneously.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Microbes don't evolve strictly by vertical descent and modification; in addition, there is persistent lateral exchange of genetic material within their local spatial neighborhood. At the present, explanatory population genetic models exist at both extrema of limits horizontal transfer rate; researchers have a reasonable, quantitative understanding of both asexual and the fully decoupled, single-site, evolution. However, there are currently no satisfactory models, and thus computational tools, in the more realistic intermediate regime, let alone that models which account for any structural variation within a population. In order to investigate such questions empirically in natural populations, we have developed a scalable multiple genome alignment tool, PanGraph, that identifies regions of mutual homology between large sets of closely related genomes. This is expected to be useful to parsimoniously infer horizontal gene transfer events within a community; perform comparative studies of genome gain, loss, and rearrangement dynamics; or simply to compress many related genomes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"PanGraph (short for pangenome graph) builds a graph-based coordinate system for polymorphic variation in a microbial population that generalizes classical linear alignment techniques. The graph is built by progressively aligning pairs of genomes using Minimap2's minimizer-based algorithm, and thus simultaneously aligns all genomes within the population in linear time. The resultant graph represents contiguous intervals of homologous DNA as vertices and every genome as an ordered walk across such vertices. Edges of the graph are unordered and only exist if at least one genome was found to connect both vertices in either the forward or reverse strand. The documentation, and source code, uses the following terminology:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Block/PanContig:  A contiguous interval of sequence that compresses a linear multiple sequence alignment and represents a single vertex within a pangraph.  It is summarized by a consensus sequence, along with the polymorphisms needed for each genome to reconstruct the true sequence.\nNode:  An oriented traversal of a genome through a block, i.e. whether a given genome/duplication traverses a block along the forward or reverse direction.  One genome can have multiple nodes that point to the same block.\nPath:  A sequence of nodes that represent an ordered walk on the graph that reconstructs an input genome.  Can be circular or linear.\nEdge:  A juxtaposition/breakpoint between two blocks found in at least one genome.\nGraph/PanGraph:  A collection of blocks, associated to all recognized intervals of homology, and paths, genomes stored as an ordered walk of nodes.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are multiple ways to install PanGraph (either the library or just command line interface)","category":"page"},{"location":"#From-Julia-REPL","page":"Home","title":"From Julia REPL","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"    (@v1.x) pkg> add https://github.com/nnoll/pangraph.git","category":"page"},{"location":"#From-Command-Line","page":"Home","title":"From Command Line","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"    julia -e 'using Pkg; Pkg.add(\"https://github.com/nnoll/pangraph.git\"); Pkg.build()'","category":"page"},{"location":"#Local-Environment","page":"Home","title":"Local Environment","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Clone the repository.","category":"page"},{"location":"","page":"Home","title":"Home","text":"    git clone https://github.com/nnoll/pangraph.git && cd pangraph","category":"page"},{"location":"","page":"Home","title":"Home","text":"Build the package. This will create a seperate Julia environment for PanGraph","category":"page"},{"location":"","page":"Home","title":"Home","text":"    julia --project=. -e 'using Pkg; Pkg.build()'","category":"page"},{"location":"","page":"Home","title":"Home","text":"Enter the REPL","category":"page"},{"location":"","page":"Home","title":"Home","text":"    julia --project=.","category":"page"},{"location":"#Binary","page":"Home","title":"Binary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Additionally, pangraph is available as a standalone, relocatable binary that should work on any Linux or MacOSX machine. Releases can be obtained from Github","category":"page"},{"location":"#Optional-dependencies","page":"Home","title":"Optional dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are a few optional external programs that PanGraph can utilize","category":"page"},{"location":"","page":"Home","title":"Home","text":"Mash can be used to construct a guide tree in place of our internal algorithm.\nMAFFT can be optionally used to polish homologous alignments. Only recommended for short alignments.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In order to invoke functionality from PanGraph, these tools must be installed and available on PATH","category":"page"},{"location":"","page":"Home","title":"Home","text":"For convenience, a script bin/setup-pangraph is provided within the repository to install both dependencies for a Linux machine without access to root. It assumes GNU coreutils are available.","category":"page"},{"location":"#User's-Guide","page":"Home","title":"User's Guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Basic functionality of PanGraph is provided by a command line interface. This includes multiple genome alignment, the export of a genome alignment to various visualization formats, alignment polishing, and genome comparison tool. Additionally, generation of basic synthetic data is included for testing. Multithreading support is baked into the provided binary. Unfortunately, due to limitations in julia, the number of threads is set by the environment variable JULIA_NUM_THREADS","category":"page"},{"location":"","page":"Home","title":"Home","text":"For uncovered use cases, functionality can be added by utilizing the underlying library functions. Please see the high-level overview for definitions of library terminology.","category":"page"},{"location":"#Citing-PanGraph","page":"Home","title":"Citing PanGraph","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Add citation here","category":"page"},{"location":"cli/build/#Build","page":"Build","title":"Build","text":"","category":"section"},{"location":"cli/build/#Description","page":"Build","title":"Description","text":"","category":"section"},{"location":"cli/build/","page":"Build","title":"Build","text":"Build a multiple sequence alignment pangraph.","category":"page"},{"location":"cli/build/#Options","page":"Build","title":"Options","text":"","category":"section"},{"location":"cli/build/","page":"Build","title":"Build","text":"Name Type Short Flag Long Flag Description\nminimum length Integer l len minimum block size for alignment graph (in nucleotides)\nblock junction cost Float b beta energy cost for interblock diversity due to alignment merger,\ncircular genomes Boolean c circular toggle if input genomes are circular\ndistance calculator String d distance-backend only accepts \"native\" or \"mash\"","category":"page"},{"location":"cli/build/#Arguments","page":"Build","title":"Arguments","text":"","category":"section"},{"location":"cli/build/","page":"Build","title":"Build","text":"Expects one or more fasta files. Multiple records within one file are treated as separate genomes Fasta files can be optionally gzipped.","category":"page"},{"location":"cli/build/#Output","page":"Build","title":"Output","text":"","category":"section"},{"location":"cli/build/","page":"Build","title":"Build","text":"Prints the constructed pangraph as a JSON to stdout.","category":"page"}]
}
