var documenterSearchIndex = {"docs":
[{"location":"lib/edge/#Edges","page":"Edges","title":"Edges","text":"","category":"section"},{"location":"lib/edge/#Types","page":"Edges","title":"Types","text":"","category":"section"},{"location":"lib/edge/","page":"Edges","title":"Edges","text":"Modules = [PanGraph.Graphs.Edges]\nOrder = [:type, :constant]","category":"page"},{"location":"lib/edge/#PanGraph.Graphs.Edges.Edge","page":"Edges","title":"PanGraph.Graphs.Edges.Edge","text":"mutable struct Edge\n    block  :: Tuple{Block, Block}\n    invert :: Bool # changes strand\n    nodes  :: Array{Position}\nend\n\nStore a unique edge within a pangraph. An edge is undirected and is defined by the two juxtaposed blocks, as well as a relative orientation. Contain all positions of all genomes that contain the edge.\n\n\n\n\n\n","category":"type"},{"location":"lib/edge/#PanGraph.Graphs.Edges.Position","page":"Edges","title":"PanGraph.Graphs.Edges.Position","text":"struct Position\n    path  :: Path\n    node  :: Tuple{Node{Block},Node{Block}}\n    index :: Tuple{Int,Int} # positions on path\n    locus :: Int # breakpoint on sequence\nend\n\nStore a single position of an edge/breakpoint between homologous pancontigs in an individual genome. path is the containing Path object. node stores the junction of nodes that represent the position of the breakpoint. index is the indices of node within path. locus is the physical location on the genome of the breakpoint.\n\n\n\n\n\n","category":"type"},{"location":"lib/edge/#Functions","page":"Edges","title":"Functions","text":"","category":"section"},{"location":"lib/edge/","page":"Edges","title":"Edges","text":"Modules = [PanGraph.Graphs.Edges]\nOrder = [:function]","category":"page"},{"location":"lib/edge/#PanGraph.Graphs.Edges.deparalog!-Tuple{Any}","page":"Edges","title":"PanGraph.Graphs.Edges.deparalog!","text":"deparalog!(G)\n\nSplit duplicated blocks that have non-intersecting, seperable paths that run in parallel and transitively connect associated genomes. Use to simplify high copy number blocks found in all individuals in equivalent contexts within pangraph G.\n\n\n\n\n\n","category":"method"},{"location":"lib/edge/#PanGraph.Graphs.Edges.edges-Tuple{Any}","page":"Edges","title":"PanGraph.Graphs.Edges.edges","text":"edges(G)\n\nCompute all edges associated with pangraph G.\n\n\n\n\n\n","category":"method"},{"location":"lib/edge/#PanGraph.Graphs.Edges.isolates-Tuple{Vector{PanGraph.Graphs.Edges.Position}}","page":"Edges","title":"PanGraph.Graphs.Edges.isolates","text":"isolates(positions::Array{Position,1})\n\nCompute the array of Position values for each isolate.\n\n\n\n\n\n","category":"method"},{"location":"lib/edge/#PanGraph.Graphs.Edges.next-Tuple{PanGraph.Graphs.Edges.Position, PanGraph.Graphs.Blocks.Block}","page":"Edges","title":"PanGraph.Graphs.Edges.next","text":"next(x::Position, blk::Block)\n\nCompute the next position from x that is connected through block blk. Use to traverse the path of an individual genome through a pangraph.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#Blocks","page":"Blocks","title":"Blocks","text":"","category":"section"},{"location":"lib/block/#Types","page":"Blocks","title":"Types","text":"","category":"section"},{"location":"lib/block/","page":"Blocks","title":"Blocks","text":"Modules = [PanGraph.Graphs.Blocks]\nOrder = [:type, :constant]","category":"page"},{"location":"lib/block/#PanGraph.Graphs.Blocks.Block","page":"Blocks","title":"PanGraph.Graphs.Blocks.Block","text":"mutable struct Block\n    uuid     :: String\n    sequence :: Array{UInt8}\n    gaps     :: Dict{Int,Int}\n    mutate   :: Dict{Node{Block},SNPMap}\n    insert   :: Dict{Node{Block},InsMap}\n    delete   :: Dict{Node{Block},DelMap}\nend\n\nStore a multiple sequence alignment of contiguous DNA related by homology. Use as a component of a larger, branching multiple genome alignment. uuid is a string identifier unique to each block sequence is the consensus (majority-rule) sequence gaps recapitulate all locations of insertions for generating the full sequence alignment. mutate, insert, and delete store polymorphisms of each genome contained within the block.\n\n\n\n\n\n","category":"type"},{"location":"lib/block/#PanGraph.Graphs.Blocks.Block-NTuple{5, Any}","page":"Blocks","title":"PanGraph.Graphs.Blocks.Block","text":"Block(sequence,gaps,mutate,insert,delete)\n\nConstruct a block with a unique uuid.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.Block-Tuple{Any, Any}","page":"Blocks","title":"PanGraph.Graphs.Blocks.Block","text":"Block(sequence,gaps)\n\nConstruct a block with a unique uuid with fixed sequence and gaps. No individuals and thus polymorphisms are initialized.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.Block-Tuple{Any}","page":"Blocks","title":"PanGraph.Graphs.Blocks.Block","text":"Block(sequence,gaps)\n\nConstruct a block with a unique uuid with fixed sequence.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.Block-Tuple{PanGraph.Graphs.Blocks.Block, Any}","page":"Blocks","title":"PanGraph.Graphs.Blocks.Block","text":"Block(b::Block, slice)\n\nReturn a subsequence associated to block b at interval slice. The returned block has a newly generated uuid.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.Block-Tuple{Vararg{PanGraph.Graphs.Blocks.Block}}","page":"Blocks","title":"PanGraph.Graphs.Blocks.Block","text":"Block(bs::Block...)\n\nConcatenate a variable number of blocks into one larger block. The returned block has a newly generated uuid.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.Block-Tuple{}","page":"Blocks","title":"PanGraph.Graphs.Blocks.Block","text":"Block(sequence,gaps)\n\nConstruct a block with a unique uuid. All fields are empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.PairPos","page":"Blocks","title":"PanGraph.Graphs.Blocks.PairPos","text":"mutable struct PairPos\n    qry :: Maybe{Pos}\n    ref :: Maybe{Pos}\nend\n\nRepresentation of matched pair of intervals within a pairwise alignment. qry can be of type Pos or Nothing ref can be of type Pos or Nothing If either ref or qry is nothing, the PairPos corresponds to an insertion or deletion respectively.\n\n\n\n\n\n","category":"type"},{"location":"lib/block/#PanGraph.Graphs.Blocks.Pos","page":"Blocks","title":"PanGraph.Graphs.Blocks.Pos","text":"mutable struct Pos\n    start :: Int\n    stop  :: Int\nend\n\nRepresentation of a single interval within a pairwise alignment. Inclusive on both ends, i.e. includes start and stop Used internally to unpack cigar strings.\n\n\n\n\n\n","category":"type"},{"location":"lib/block/#Functions","page":"Blocks","title":"Functions","text":"","category":"section"},{"location":"lib/block/","page":"Blocks","title":"Blocks","text":"Modules = [PanGraph.Graphs.Blocks]\nOrder = [:function]","category":"page"},{"location":"lib/block/#Base.append!-Tuple{PanGraph.Graphs.Blocks.Block, PanGraph.Graphs.Nodes.Node{PanGraph.Graphs.Blocks.Block}, Union{Nothing, Dict{Int64, UInt8}}, Union{Nothing, Dict{Tuple{Int64, Int64}, Vector{UInt8}}}, Union{Nothing, Dict{Int64, Int64}}}","page":"Blocks","title":"Base.append!","text":"append!(b::Block, node::Node{Block}, snp::Maybe{SNPMap}, ins::Maybe{InsMap}, del::Maybe{DelMap})\n\nAdds a new genome at node to multiple sequence alignment block b. Polymorphisms are optional. If nothing is passed instead, an empty dictionary will be used.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#Base.length-Tuple{PanGraph.Graphs.Blocks.Block, PanGraph.Graphs.Nodes.Node}","page":"Blocks","title":"Base.length","text":"length(b::Block, n::Node)\n\nReturn the length of the sequence of node n within the multiple alignment of block b.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#Base.length-Tuple{PanGraph.Graphs.Blocks.Block}","page":"Blocks","title":"Base.length","text":"length(b::Block)\n\nReturn the length of consensus sequence of the multiple alignment of block b.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#Base.pop!-Tuple{PanGraph.Graphs.Blocks.Block, PanGraph.Graphs.Nodes.Node}","page":"Blocks","title":"Base.pop!","text":"pop!(b::Block, n::Node)\n\nRemove genome of Node n from Block b.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.allele_positions-Tuple{Dict{Int64, UInt8}, Dict{Tuple{Int64, Int64}, Vector{UInt8}}, Dict{Int64, Int64}}","page":"Blocks","title":"PanGraph.Graphs.Blocks.allele_positions","text":"allele_positions(snp::SNPMap, ins::InsMap, del::DelMap)\n\nReturn an iterator over polymorphic loci, i.e. SNPs and Indels. The iterator will be sorted by position in ascending order.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.allele_positions-Tuple{PanGraph.Graphs.Blocks.Block, PanGraph.Graphs.Nodes.Node}","page":"Blocks","title":"PanGraph.Graphs.Blocks.allele_positions","text":"allele_positions(b::Block, n::Node)\n\nReturn an iterator over polymorphic loci for node n contained within block b The iterator will be sorted by position in ascending order.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.applyalleles-NTuple{4, Any}","page":"Blocks","title":"PanGraph.Graphs.Blocks.applyalleles","text":"applyalleles(seq::Array{UInt8}, mutate::SNPMap, insert::InsMap, delete::DelMap)\n\nTake a sequence and apply polymorphisms, as given by mutate, insert, and delete. Return the brand new allocated sequence.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.assert_equals-Tuple{PanGraph.Graphs.Blocks.Block, PanGraph.Graphs.Blocks.Block}","page":"Blocks","title":"PanGraph.Graphs.Blocks.assert_equals","text":"assert_equal(b₁::Block, b₂::Block)\n\nThrow an error in block b₁ is not equivalent to block b₂. Useful for internal debugging.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.check-Tuple{PanGraph.Graphs.Blocks.Block}","page":"Blocks","title":"PanGraph.Graphs.Blocks.check","text":"check(b::Block)\n\nCheck whether block b is internally self-consistent. Useful for debugging internals.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.combine-Tuple{PanGraph.Graphs.Blocks.Block, PanGraph.Graphs.Blocks.Block, PanGraph.Graphs.Utility.Alignment}","page":"Blocks","title":"PanGraph.Graphs.Blocks.combine","text":"combine(qry::Block, ref::Block, aln::Alignment; minblock=500)\n\nTake a pairwise alignment aln from the consensus of qry to ref and merge both. The resultant new block, with a novel uuid is returned. Alignment aln is a segmented set of intervals mapping homologous regions of one block into the other. Parameter minblock is the cutoff length of an indel, above which a new block will be created.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.depth-Tuple{PanGraph.Graphs.Blocks.Block}","page":"Blocks","title":"PanGraph.Graphs.Blocks.depth","text":"depth(b::Block)\n\nReturn the number of genomes contained within the alignment\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.diversity-Tuple{PanGraph.Graphs.Blocks.Block}","page":"Blocks","title":"PanGraph.Graphs.Blocks.diversity","text":"diversity(b::Block)\n\nReturn the averaged fraction of loci that are mutated within the multiple sequence alignment of block b.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.partition-Tuple{Any}","page":"Blocks","title":"PanGraph.Graphs.Blocks.partition","text":"partition(alignment; minblock=500)\n\nParse the alignment into matched intervals of a pairwise alignment. If any insertion or deletion is larger than minblock, a new block is created to hold the homologous interval. This ensures that all blocks are at least minblock long and no block contains an insertion or deletion longer than itself.\n\nalignment is assumed to be an data structure from the Utility module\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.reconsensus!-Tuple{PanGraph.Graphs.Blocks.Block}","page":"Blocks","title":"PanGraph.Graphs.Blocks.reconsensus!","text":"reconsensus!(b::Block)\n\nUpdate the consensus sequence of block b by majority-rule over the multiple sequence alignment.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.regap!-Tuple{PanGraph.Graphs.Blocks.Block}","page":"Blocks","title":"PanGraph.Graphs.Blocks.regap!","text":"regap!(b::Block)\n\nRecompute the positions of gaps within the multiple sequence of block b\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.rereference-Tuple{PanGraph.Graphs.Blocks.Block, PanGraph.Graphs.Blocks.Block, Any}","page":"Blocks","title":"PanGraph.Graphs.Blocks.rereference","text":"rerefence(qry::Block, ref::Block, aligment)\n\nTake a pairwise alignment segments from the consensus of qry to ref and rereference all polymorphisms of qry to the consensus sequence of `ref. Low-level function used by higher-level API.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.swap!-Tuple{PanGraph.Graphs.Blocks.Block, Array{PanGraph.Graphs.Nodes.Node{PanGraph.Graphs.Blocks.Block}}, PanGraph.Graphs.Nodes.Node{PanGraph.Graphs.Blocks.Block}}","page":"Blocks","title":"PanGraph.Graphs.Blocks.swap!","text":"swap!(b::Block, oldkey::Array{Node{Block}}, newkey::Node{Block})\n\nRemove all polymorphisms associated to all keys within oldkey. Concatenate and reassociate them to newkey.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.Blocks.swap!-Tuple{PanGraph.Graphs.Blocks.Block, PanGraph.Graphs.Nodes.Node{PanGraph.Graphs.Blocks.Block}, PanGraph.Graphs.Nodes.Node{PanGraph.Graphs.Blocks.Block}}","page":"Blocks","title":"PanGraph.Graphs.Blocks.swap!","text":"swap!(b::Block, oldkey::Node{Block}, newkey::Node{Block})\n\nRemove all polymorphisms associated to oldkey and reassociate them to newkey.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.marshal_fasta-Tuple{IO, PanGraph.Graphs.Blocks.Block}","page":"Blocks","title":"PanGraph.Graphs.marshal_fasta","text":"marshal_fasta(io::IO, b::Block; opt=nothing)\n\nSerialize the multiple sequence alignment of block b to a fasta format to IO stream io. Each sequence will be serialized as-is, i.e. with no gaps.\n\nIf opt is not nothing, the output will be an aligned fasta file. Futhermore, opt is interpreted as a function to be called per internal node that gives a unique name for each fasta record that is generated per node.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.reverse_complement-Tuple{PanGraph.Graphs.Blocks.Block}","page":"Blocks","title":"PanGraph.Graphs.reverse_complement","text":"reverse_complement(b::Block; keepid=false)\n\nReturn the reverse complement of the multiple sequence alignment within Block b. By default, will return a block with a new uuid, unless keepid is set to true.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.sequence!-Tuple{Any, PanGraph.Graphs.Blocks.Block, PanGraph.Graphs.Nodes.Node{PanGraph.Graphs.Blocks.Block}}","page":"Blocks","title":"PanGraph.Graphs.sequence!","text":"sequence!(seq, b::Block, node::Node{Block}; gaps=false)\n\nMutate the sequence buffer seq in place to hold the sequence associated to genome node within sequence alignment of block b. By default, gaps (charater '-') will not be returned, unless gaps is set to true. Return the sequence with gap characters to generate the full sequence alignment.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.sequence-Tuple{PanGraph.Graphs.Blocks.Block, PanGraph.Graphs.Nodes.Node{PanGraph.Graphs.Blocks.Block}}","page":"Blocks","title":"PanGraph.Graphs.sequence","text":"sequence(seq, b::Block, node::Node{Block}; gaps=false, forward=false)\n\nReturn the sequence associated to genome node within sequence alignment of block b. By default, gaps (charater '-') will not be returned, unless gaps is set to true. Return the sequence with gap characters can be used to generate the full sequence alignment. If forward is true, the true orientation of the genome is ignored and will be returned to align to the forward consensus.\n\n\n\n\n\n","category":"method"},{"location":"lib/block/#PanGraph.Graphs.sequence-Tuple{PanGraph.Graphs.Blocks.Block}","page":"Blocks","title":"PanGraph.Graphs.sequence","text":"sequence(b::Block; gaps=false)\n\nReturn the consensus of the multiple sequence alignment within block b. By default, gaps (charater '-') will not be returned, unless gaps is set to true. Return the consensus alignment with gaps is useful for generating the full sequence alignment.\n\n\n\n\n\n","category":"method"},{"location":"lib/gfa/#GFA","page":"GFA","title":"GFA","text":"","category":"section"},{"location":"lib/gfa/#Types","page":"GFA","title":"Types","text":"","category":"section"},{"location":"lib/gfa/","page":"GFA","title":"GFA","text":"Modules = [PanGraph.Graphs.GFA]\nOrder = [:type, :constant]","category":"page"},{"location":"lib/gfa/#PanGraph.Graphs.GFA.Path","page":"GFA","title":"PanGraph.Graphs.GFA.Path","text":"struct Path\n    name     :: String\n    segments :: Array{Node,1}\n    circular :: Bool\nend\n\nStore a GFA path, i.e. a sequence of segments that represents an observed genome.\n\n\n\n\n\n","category":"type"},{"location":"lib/gfa/#PanGraph.Graphs.GFA.Segment","page":"GFA","title":"PanGraph.Graphs.GFA.Segment","text":"struct Segment\n    name     :: String\n    sequence :: Array{UInt8}\n    depth    :: Int\nend\n\nStore a GFA segment, i.e. an edge of an alignment graph that holds a contiguous sequence Depth is the number of genomes, including duplications, that contain the sequence.\n\n\n\n\n\n","category":"type"},{"location":"lib/gfa/#Functions","page":"GFA","title":"Functions","text":"","category":"section"},{"location":"lib/gfa/","page":"GFA","title":"GFA","text":"Modules = [PanGraph.Graphs.GFA]\nOrder = [:function]","category":"page"},{"location":"lib/gfa/#PanGraph.Graphs.marshal_gfa-Tuple{IO, PanGraph.Graphs.Graph}","page":"GFA","title":"PanGraph.Graphs.marshal_gfa","text":"marshal_gfa(io::IO, G::Graph; opt=nothing)\n\nOutput pangraph G to IO stream io. opt can include two functions, to be accessed in fields connect and output. connect is a function that takes a node and returns true or false if it should be connected in the GFA output. output is an equivalent function signature, but controls whether the node is output at all.\n\n\n\n\n\n","category":"method"},{"location":"lib/node/#Nodes","page":"Nodes","title":"Nodes","text":"","category":"section"},{"location":"lib/node/#Types","page":"Nodes","title":"Types","text":"","category":"section"},{"location":"lib/node/","page":"Nodes","title":"Nodes","text":"Modules = [PanGraph.Graphs.Nodes]\nOrder = [:type, :constant]","category":"page"},{"location":"lib/node/#PanGraph.Graphs.Nodes.Node","page":"Nodes","title":"PanGraph.Graphs.Nodes.Node","text":"mutable struct Node{T}\n\tblock  :: T\n\tstrand :: Bool\nend\n\nNode represents a portion of a sequence path that passes through a single block. strand stores whether we pass along the forward strand of block (if true) or reverse (if false).\n\n\n\n\n\n","category":"type"},{"location":"lib/node/#PanGraph.Graphs.Nodes.Node-Tuple{T} where T","page":"Nodes","title":"PanGraph.Graphs.Nodes.Node","text":"Node{T}(b::T; strand=true)\n\nCreate a Node that passed through block b. Default to forward strand orientation.\n\n\n\n\n\n","category":"method"},{"location":"lib/node/#Functions","page":"Nodes","title":"Functions","text":"","category":"section"},{"location":"lib/node/","page":"Nodes","title":"Nodes","text":"Modules = [PanGraph.Graphs.Nodes]\nOrder = [:function]","category":"page"},{"location":"lib/node/#Base.length-Tuple{PanGraph.Graphs.Nodes.Node}","page":"Nodes","title":"Base.length","text":"length(n::Node) = length(n.block, n)\n\nReturn the length of sequence stored within node n\n\n\n\n\n\n","category":"method"},{"location":"lib/mash/#Mash-Implementation","page":"Mash Implementation","title":"Mash Implementation","text":"","category":"section"},{"location":"lib/mash/#Types","page":"Mash Implementation","title":"Types","text":"","category":"section"},{"location":"lib/mash/","page":"Mash Implementation","title":"Mash Implementation","text":"Modules = [PanGraph.Graphs.Mash]\nOrder = [:type, :constant]","category":"page"},{"location":"lib/mash/#PanGraph.Graphs.Mash.Minimizer","page":"Mash Implementation","title":"PanGraph.Graphs.Mash.Minimizer","text":"struct Minimizer\n    value    :: UInt64\n    position :: UInt64\nend\n\nA minimizer is a kmer that, given a hash function that maps kmers to integers, is the minimum kmer within a given set of kmers. The value is the result of applying the hash function to the kmer. The position is a bitpacked integer that includes reference ID, locus, and strand\n\n\n\n\n\n","category":"type"},{"location":"lib/mash/#Functions","page":"Mash Implementation","title":"Functions","text":"","category":"section"},{"location":"lib/mash/","page":"Mash Implementation","title":"Mash Implementation","text":"Modules = [PanGraph.Graphs.Mash]\nOrder = [:function]","category":"page"},{"location":"lib/mash/#PanGraph.Graphs.Mash.distance-Tuple","page":"Mash Implementation","title":"PanGraph.Graphs.Mash.distance","text":"distance(graphs...; k=15, w=100)\n\nCompute the pairwise distance between all input graphs. Distance is the set distance between minimizers. Linear-time algorithm using hash collisions.\n\n\n\n\n\n","category":"method"},{"location":"lib/mash/#PanGraph.Graphs.Mash.hash-Tuple{UInt64, UInt64}","page":"Mash Implementation","title":"PanGraph.Graphs.Mash.hash","text":"hash(x::UInt64, mask::UInt64)\n\nA transliteration of Jenkin's invertible hash function for 64 bit integers. Bijectively maps any kmer to an integer.\n\n\n\n\n\n","category":"method"},{"location":"lib/mash/#PanGraph.Graphs.Mash.sketch-Tuple{Array{UInt8}, Int64, Int64, Int64}","page":"Mash Implementation","title":"PanGraph.Graphs.Mash.sketch","text":"sketch(seq::Array{UInt8}, k::Int, w::Int, id::Int)\n\nSketch a linear sequence into a vector of minimizers. k sets the kmer size. w sets the number of contiguous kmers that will be used in the window minimizer comparison. id is a unique integer that corresponds to the sequence. It will be bitpacked into the minimizer position.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/tutorial_2/#The-structure-of-Pangraph-output-file","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"","category":"section"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"In this second part of the tutorial we will explore in more detail the content of the json output file produced by the build command. As an example, we will use snippets from the ecoli_pangraph.json file that was produced in the previous section of the tutorial.","category":"page"},{"location":"tutorials/tutorial_2/#The-structure-of-pangraph.json","page":"The structure of Pangraph output file","title":"The structure of pangraph.json","text":"","category":"section"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"As discussed in the previous tutorial section, the two main entries of pangraph output file are paths and blocks.","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"each entry in the paths list encodes one of the nucleotide sequences that were given as input to the build command, represented as a list of blocks.\neach entry in the blocks list represents an alignable set of homologous sequences. A block contains the consensus of all of these sequences, together with information to reconstruct the full alignment.","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"We will explore each of these two categories separately.","category":"page"},{"location":"tutorials/tutorial_2/#Blocks","page":"The structure of Pangraph output file","title":"Blocks","text":"","category":"section"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"Here is an example of an entry of the blocks list, from the ecoli_pangraph.json file.","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"{\n    \"id\": \"TMEPNAOFAP\",\n    \"sequence\": \"CGGGAAGGTTCTGATGCGTCCGTGTTAAACTAAGAGAATCTATCT...\",\n    \"gaps\": { ... },\n    \"mutate\": [ ... ],\n    \"insert\": [ ... ],\n    \"delete\": [ ... ],\n    \"positions\": [\n        [\n            { \"name\": \"NZ_CP019944\", \"number\": 1, \"strand\": true },\n            [ 356656, 359732 ]\n        ],\n        [\n            { \"name\": \"NC_013361\", \"number\": 1, \"strand\": false},\n            [ 4496907, 4500032 ]\n        ],\n        [\n            { \"name\": \"NZ_CP015912\", \"number\": 1, \"strand\": false},\n            [ 2485802, 2488871 ]\n        ],\n        ...\n    ]\n},","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"The two main properties of a block are its unique id (10-letters alphabetic sequence randomly assigned when generating the pangraph), and the consensus sequence.","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"In addition to this, a block object also stores information on the full alignment of all the different occurrences of the block, and their position on the original input sequences. As explained in the Introduction, we refer to a particular occurrence of a block in a sequence as a Node. Intuitively, they can be thought of as a single entry in the sequence alignment of a block.","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"Each node of a block can be uniquely identified by its \"node-id\", which is an object composed of three entries:","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"{ \"name\": \"NZ_CP019944\", \"number\": 1, \"strand\": true }","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"a name, indicating on which of the input sequences the node is found.\na number, indicating whether this is the first, second, third... occurrence of the block on a given input sequence. This is important to distinguish different nodes of a duplicated blocks, when they occurr in the same input sequence.\na strand boolean value, indicating wheter the node is found on the forward (true) or reverse (false) strand.","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"The \"node-id\" is used for example in the position field of a block. This field contains information on the location of nodes on the input sequences. It consists of a list of pairs. The first entry of the pair is the node-id, indicating of which occurrence of the block the position refers to. The second entry is a pair of numbers indicating the position of the beginning and end of the node on the input sequence.","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"In the example above, the first entry of positions indicates that block \"TMEPNAOFAP\" is found on the forward strand of the chromosome labeled NZ_CP019944, at position 356656 to 359732. Positions are always in 1-based numbering and based on the forward strand (with beginning < end). The only exception is when a block wraps around the end of a circular sequence. In this case the node start position (close to the end of the genome) is higher than the node end position (close to the beginning of the genome).","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"The fields gaps, mutate, insert and delete contain information to reconstruct the block alignment. They were left out from this example for simplicity, and are discussed in the next subsection.","category":"page"},{"location":"tutorials/tutorial_2/#How-alignments-are-encoded","page":"The structure of Pangraph output file","title":"How alignments are encoded","text":"","category":"section"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"A block object contains the information on the alignment of all the homologous sequences belonging to the block. This information is stored in compressed format in the gaps, mutate, insert and delete fields. In practice the alignment of each node sequence can be obtained from the consensus by adding the gaps, single-nucleotide mutations, and insertions / deletions contained in these fields.","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"Here we briefly describe each entry, and then schematically show how these can be combined to obtain the alignment sequence of a node.","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"note: reconstructing the alignments\nRather than providing explicit instructions on how to build the alignments, the aim of this part of the tutorial is to show how the information is organized in the pangraph output format. For a quick way to obtain block alignments, have a look at the next tutorial section Polishing the pangraph and exploring alignments.","category":"page"},{"location":"tutorials/tutorial_2/#Gaps","page":"The structure of Pangraph output file","title":"Gaps","text":"","category":"section"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"The gaps entry contains a json object that indicates where gaps should be added to the consensus sequence as a first step towards reconstructing the alignment. The first item represents the position of the gap, and the second its length.","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"\"gaps\" : {\"0\": 27, \"53\": 1 }","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"In this example the consensus sequence contains two gaps: one is inserted at the beginning of the consensus sequence, with length 27, and one after sequence position 53, with length 1. In some of the sequences running through this block, these gaps are filled with insertions, see below.","category":"page"},{"location":"tutorials/tutorial_2/#Single-nucleotide-mutations","page":"The structure of Pangraph output file","title":"Single-nucleotide mutations","text":"","category":"section"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"The mutate entry encodes single-nucleotide mutations. It contains a list of pairs. Each pair is relative to a particular node (i.e. one line in the alignment) and the first item of the pair is the node-id described above. The second entry is a list of mutations (potentially empty). Each mutation is specified by its position on the original sequence, and the nucleotide that should be substituted to the consensus.","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"\"mutate\" : [\n    [\n        { \"name\": \"NC_009800\", \"number\": 1, \"strand\": false },     // node-id\n        [ [415,\"C\"], [1526,\"T\"], [2827,\"G\"], ... ]                 // list of mutations\n    ],\n    [\n        { \"name\": \"NZ_CP011342\", \"number\": 1, \"strand\": false },   // node-id\n        [ [2221, \"G\"], [415, \"C\"], [2494, \"T\"], [1825, \"A\"], ... ] // list of mutations\n    ],\n    [\n        { \"name\": \"NZ_CP019944\", \"number\": 1, \"strand\": true },    // node-id\n        [ [2827, \"G\"], [442, \"T\"], [2713, \"G\"], ... ]              // list of mutations\n    ],\n    ...\n],","category":"page"},{"location":"tutorials/tutorial_2/#Insertions-and-deletions","page":"The structure of Pangraph output file","title":"Insertions and deletions","text":"","category":"section"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"Entries of insert and delete are organized similarly to mutations. They appear in lists of pairs, whose first item is the node-id, and the second is the list of insertions/deletions that one needs to include. This list can potentially be empty.","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"\"insert\" : [\n    [\n        { \"name\": \"NC_009800\", \"number\": 1, \"strand\": false },\n        []\n    ],\n    [\n        { \"name\": \"NZ_CP011342\", \"number\": 1, \"strand\": false },\n        []\n    ],\n    [\n        { \"name\": \"NZ_CP019944\", \"number\": 1, \"strand\": true },\n        [ [ [0,0], \"TT\"], [ [0,15], \"TTCCC\"] ]\n    ],\n    ...\n],","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"Insertions are always placed inside of gaps. They appear in the form [ [gap-beg, gap-offset], \"seq\"]. gap-beg indicates the beginning position of the gap, and gap-offset indicates how far from the beginning of this gap the insertion starts. Finally seq is the nucleotide sequence to be inserted.","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"\"delete\" : [\n    [\n        { \"name\": \"NC_009800\", \"number\": 1, \"strand\": false },\n        [ [ 3071, 56 ] ]\n    ],\n    [\n        { \"name\": \"NZ_CP011342\", \"number\": 1, \"strand\": false },\n        []\n    ],\n    [\n        { \"name\": \"NZ_CP019944\", \"number\": 1, \"strand\": true },\n        [ [ 3071, 56 ] ]\n    ],\n    ...\n],","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"Deletions are instead in the form [del-beg, del-length] where the first number indicates the position at which the deletion starts (relative to the consensus sequence) and the second is the deletion length.","category":"page"},{"location":"tutorials/tutorial_2/#From-block-consensus-to-node-alignment","page":"The structure of Pangraph output file","title":"From block consensus to node alignment","text":"","category":"section"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"Below is a schematic summary of how gaps, mutations, insertions and deletions can be combined to go from the block consensus sequence to the alignment sequence of a particular node.","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"(Image: img)","category":"page"},{"location":"tutorials/tutorial_2/#Paths","page":"The structure of Pangraph output file","title":"Paths","text":"","category":"section"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"A path object has the following structure:","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"{\n    \"name\": \"NZ_CP010242\",\n    \"offset\": -3044650,\n    \"circular\": true,\n    \"position\": [ 1695501, 1696243, 1702666, ... ],\n    \"blocks\": [\n        { \"id\": \"IUZTZPLBVS\", \"name\": \"NZ_CP010242\", \"number\": 1, \"strand\": true },\n        { \"id\": \"DVEJPZTOYJ\", \"name\": \"NZ_CP010242\", \"number\": 1, \"strand\": true },\n        { \"id\": \"FUECJYRQOZ\", \"name\": \"NZ_CP010242\", \"number\": 1, \"strand\": true },\n        ...\n    ]\n},","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"The two main properties of a path are name and blocks. The name of the path indicates which of the input sequences the path represents. blocks contains the ordered list of nodes that make up the path. Each node is identified by the unique block id, and by the entries of the node-id (name, number, strand).","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"Here is a complete list containing a description of every entry in the path object:","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"name : the name of the particular nucleotide sequence to whom the path refers. This name is extracted from the sequence id in the input fasta file.\ncircular : indicates whether the considered sequence is circular (e.g. plasmid) or not. This is controlled by the --circular option of the build command.\nblocks : the ordered list of blocks that make up the path.\nid : the unique random id of the block, assigned when building the graph.\nname, number strand : entries of the node-id, used to identify which particular instance of the block is part of the path. As a reminder, name is the id of the input sequence, number indicates which occurrence of the same block is considered (useful for duplicated blocks) and strand indicates whether the sequence is found on the forward or reverse strand.\nposition : an ordered list of positions, corresponding to the beginning positions of each node in the path.\noffset : indicates the distance between the beginning of the input sequence, and the beginning of the path (i.e. the beginning of the first node of the path, block IUZTZPLBVS in the example above).","category":"page"},{"location":"tutorials/tutorial_2/#A-look-at-the-length-and-frequency-of-blocks","page":"The structure of Pangraph output file","title":"A look at the length and frequency of blocks","text":"","category":"section"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"Having completed this part of the tutorial, it is now possible to access directly the rich information contained in the pangraph output format.","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"As a simple example, we take the ecoli_pangraph.json file and extract from each block the length of its consensus sequence, and the number of unique E.Coli strains that contain the block. We then plot the cumulative distribution of block lengths, and the frequency distribution of blocks (weighted by length).","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"(Image: img)","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"The blocks present in this pangraph have widely varying size, with some blocks being only some hundreds of nucleotides long, and others spanning tens of kbps.[1]","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"[1]: The almost complete absence of blocks shorter than 100 bps is due to the default value of the --len option in the build command, which is set to 100. See Build.","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"The block frequency distribution shows a typical bimodal pattern, with an abundance of \"core\" blocks (blocks that are present in all the 10 considered chromosomes, cumulative length of more than 3.5 Mbps) and rare blocks present in only one strain (cumulative length of more than 2.5 Mbps). This graph can be reproduced by this python snippet:","category":"page"},{"location":"tutorials/tutorial_2/","page":"The structure of Pangraph output file","title":"The structure of Pangraph output file","text":"import json\nimport matplotlib.pyplot as plt\n\nwith open('ecoli_pangraph.json') as fh:\n    G = json.load(fh)\n\nblocks = [{'length':len(x['sequence']), 'depth':len(x['positions'])} for x in G['blocks']]\nplt.hist([x['depth'] for x in blocks], weights=[x['length'] for x in blocks], bins=range(1,11))","category":"page"},{"location":"tutorials/tutorial_4/#Projecting-the-graph-on-a-subset-of-strains.","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"","category":"section"},{"location":"tutorials/tutorial_4/","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"In this final part of the tutorial we show how to use the marginalize command. This command is used when one is interested in the relationship between a subset of the genomes that make up the pangraph. It can quickly create, starting from the full pangraph, a smaller pangenome graph relative to the selected subset of strains.","category":"page"},{"location":"tutorials/tutorial_4/#Preliminary-steps","page":"Projecting the graph on a subset of strains.","title":"Preliminary steps","text":"","category":"section"},{"location":"tutorials/tutorial_4/","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"We will run this tutorial on a different dataset, containing 10 complete chromosomes of Klebsiella Pneumoniae (source: GenBank). These sequences are available in the pangraph repository (example_dataset/klebs.fa.gz) and can be downloaded by running:","category":"page"},{"location":"tutorials/tutorial_4/","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"wget https://github.com/neherlab/pangraph/raw/master/example_datasets/klebs.fa.gz","category":"page"},{"location":"tutorials/tutorial_4/","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"As for the previous dataset, we can create the pangraph with the command:","category":"page"},{"location":"tutorials/tutorial_4/","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"pangraph build --circular klebs.fa.gz > klebs_pangraph.json","category":"page"},{"location":"tutorials/tutorial_4/","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"On 4 cores the command should complete in around 6 mins. After creating the pangraph, we can export it in gfa format for visualization.","category":"page"},{"location":"tutorials/tutorial_4/","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"pangraph export \\\n    --no-duplications \\\n    --output-directory klebs_export \\\n    --prefix klebs_pangraph \\\n    klebs_pangraph.json","category":"page"},{"location":"tutorials/tutorial_4/","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"This will create the file klebs_export/klebs_pangraph.gfa which can be visualized using Bandage.","category":"page"},{"location":"tutorials/tutorial_4/","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"(Image: img)","category":"page"},{"location":"tutorials/tutorial_4/","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"Colors indicate the number of times a block occurs. Blocks that appear in red are core blocks that are found in every chromosome, while black blocks are only present in a few strains. We used the --no-duplication flag in the export command, which excludes duplicated blocks from the exported graph. This simplifies the visualization, which would otherwise be highly \"tangled-up\" by these duplications.","category":"page"},{"location":"tutorials/tutorial_4/#Marginalize-the-graph-on-a-subset-of-strains","page":"Projecting the graph on a subset of strains.","title":"Marginalize the graph on a subset of strains","text":"","category":"section"},{"location":"tutorials/tutorial_4/","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"The full graph might be difficult to interpret. However if we are interested only in relationships between a subset of chromosomes we can use the command marginalize (see Marginalize) to project the pangraph on this set of strains. This \"marginalization\" operation will remove transitive edges. If two blocks always come one after the other (with same strandedness) in all of the subset of strains one is interested in, these blocks will be merged in a new larger block. This can greatly simplify the pangenome graph, and highlight differences between a particular subset of strains. And it is also computationally much faster than building a new pangraph directly from the sequences of interest.","category":"page"},{"location":"tutorials/tutorial_4/","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"For this example we will consider the pair of strains NZ_CP013711 and NC_017540.[1] We can marginalize the pangraph on these two strains by running:","category":"page"},{"location":"tutorials/tutorial_4/","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"[1]: here we consider a marginalization on two strains, but one can marginalize the pangraph on any number of strains.","category":"page"},{"location":"tutorials/tutorial_4/","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"pangraph marginalize \\\n    --strains NZ_CP013711,NC_017540 \\\n    klebs_pangraph.json > klebs_marginal_pangraph.json","category":"page"},{"location":"tutorials/tutorial_4/","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"The file klebs_marginal_pangraph.json will contain the new marginalized pangraph. The strains on which one projects are specified with the flag --strains. They must be passed as a comma separated list of sequence ids, without spaces.","category":"page"},{"location":"tutorials/tutorial_4/","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"note: producing all pairwise marginalizations\nIf the command marginalize is executed without specifying particular strains, but providing an output directory with the option --output-path, then it will automatically produce all pairwise marginalizations and save them in the specified directory.","category":"page"},{"location":"tutorials/tutorial_4/#A-look-at-the-marginalized-pangraph","page":"Projecting the graph on a subset of strains.","title":"A look at the marginalized pangraph","text":"","category":"section"},{"location":"tutorials/tutorial_4/","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"As done for the main pangraph, we can export the marginalized pangraph in gfa format:","category":"page"},{"location":"tutorials/tutorial_4/","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"pangraph export \\\n    --no-duplications \\\n    --output-directory klebs_export \\\n    --prefix klebs_marginal_pangraph \\\n    klebs_marginal_pangraph.json","category":"page"},{"location":"tutorials/tutorial_4/","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"This will produce the file klebs_export/klebs_marginal_pangraph.gfa which can be visualized with Bandage.","category":"page"},{"location":"tutorials/tutorial_4/","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"(Image: img)","category":"page"},{"location":"tutorials/tutorial_4/","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"As expected the marginalized pangraph contains fewer blocks than the original one (388 vs 1244), and blocks are on average longer (mean length: 14 kbp vs 6 kbp). Blocks that appear in red are shared by both strains, while black blocks are present in only one of the two strains. The pangraph is composed of two stretches of syntenic blocks, which are in contact in a central point. This structure can be understood by comparing the two chromosomes with a dotplot. Using D-Genies on the two sequences[2] we obtain the following:","category":"page"},{"location":"tutorials/tutorial_4/","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"[2]: to simplify the visualization, the chromosome of strain NZ_CP013711 was reverse-complemented and shifted of ~ 0.1 Mbp, so that most of the matches lay on the diagonal.","category":"page"},{"location":"tutorials/tutorial_4/","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"(Image: img)","category":"page"},{"location":"tutorials/tutorial_4/","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"The contact point between the two loops in the pangraph is caused by the fact that the two genomes are composed of two mostly syntenic subsequences (the two loops) but these loops are concatenated with two different strandedness in the two strains. If we were to draw the two paths (relative to the two chromosomes) with different colors on top of the pangraph we would observe something similar to this:","category":"page"},{"location":"tutorials/tutorial_4/","page":"Projecting the graph on a subset of strains.","title":"Projecting the graph on a subset of strains.","text":"(Image: img)","category":"page"},{"location":"lib/simulate/#Simulation","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"lib/simulate/#Types","page":"Simulation","title":"Types","text":"","category":"section"},{"location":"lib/simulate/","page":"Simulation","title":"Simulation","text":"Modules = [PanGraph.Simulation]\nOrder = [:type, :constant]","category":"page"},{"location":"lib/simulate/#PanGraph.Simulation.Params","page":"Simulation","title":"PanGraph.Simulation.Params","text":"struct Params\n\tN    :: Int\n\tL    :: Int\n\tσ    :: Int\n\trate :: Rates\nend\n\nStore all parameters of a single recombinative Wright-Fisher model. N is the population size. L is the expected genome size of all descendants. σ is the variance of genome size of all descendants. rate is the various rate of evolutionary processes.\n\n\n\n\n\n","category":"type"},{"location":"lib/simulate/#PanGraph.Simulation.Rates","page":"Simulation","title":"PanGraph.Simulation.Rates","text":"struct Rates\n\tsnp :: Float64\n\thgt :: Float64\n\tdel :: Float64\n\tinv :: Float64\nend\n\nStore the rates of evolution of mutation snp, recombination hgt, deletion del, and inversion inv.\n\n\n\n\n\n","category":"type"},{"location":"lib/simulate/#PanGraph.Simulation.Sequence","page":"Simulation","title":"PanGraph.Simulation.Sequence","text":"Sequence = Array{UInt64,1}\n\nA bitpacked array of sequence state. Each UInt64 bits are interpreted as\n\n30 bytes(ancestor) | 30 bytes (location) | 3 bytes (mutation) | 1 byte strand\n\n\n\n\n\n","category":"type"},{"location":"lib/simulate/#Functions","page":"Simulation","title":"Functions","text":"","category":"section"},{"location":"lib/simulate/","page":"Simulation","title":"Simulation","text":"Modules = [PanGraph.Simulation]\nOrder = [:function]","category":"page"},{"location":"lib/simulate/#PanGraph.Simulation.delete!-Tuple{Vector{UInt64}, Int64, Int64}","page":"Simulation","title":"PanGraph.Simulation.delete!","text":"delete!(s::Sequence, from::Int, to::Int)\n\nDelete the interval from:to from sequence s.\n\n\n\n\n\n","category":"method"},{"location":"lib/simulate/#PanGraph.Simulation.insert!-Tuple{Vector{UInt64}, Vector{UInt64}, Int64}","page":"Simulation","title":"PanGraph.Simulation.insert!","text":"insert!(acceptor::Sequence, donor::Sequence, at::Int)\n\nInsert sequence donor into acceptor at locus at.\n\n\n\n\n\n","category":"method"},{"location":"lib/simulate/#PanGraph.Simulation.invert!-Tuple{Vector{UInt64}, Int64, Int64}","page":"Simulation","title":"PanGraph.Simulation.invert!","text":"invert!(s::Sequence, from::Int, to::Int)\n\nReplace the interval from:to of sequence s with its reverse complement.\n\n\n\n\n\n","category":"method"},{"location":"lib/simulate/#PanGraph.Simulation.model-Tuple{PanGraph.Simulation.Params}","page":"Simulation","title":"PanGraph.Simulation.model","text":"model(param::Params)\n\nReturn an evolution function based upon parameters param.\n\n\n\n\n\n","category":"method"},{"location":"lib/simulate/#PanGraph.Simulation.mutate!-Tuple{Vector{UInt64}, Int64}","page":"Simulation","title":"PanGraph.Simulation.mutate!","text":"mutate!(s::Sequence, at::Int)\n\nApply a random mutation to sequence s at locus at.\n\n\n\n\n\n","category":"method"},{"location":"lib/simulate/#PanGraph.Simulation.nucleotide-Tuple{Array{Vector{UInt64}}, Vector{Vector{UInt8}}}","page":"Simulation","title":"PanGraph.Simulation.nucleotide","text":"nucleotide(sequence::Array{Sequence}, ancestor::Array{Array{UInt8,1},1})\n\nGenerate the set of extant sequences from the ancestral mosiacs sequence and the original sequences ancestor.\n\n\n\n\n\n","category":"method"},{"location":"lib/simulate/#PanGraph.Simulation.pancontig!-Tuple{Vector{UInt64}, Dict{Int64, Array{PanGraph.Graphs.Intervals.Interval}}}","page":"Simulation","title":"PanGraph.Simulation.pancontig!","text":"pancontig!(s::Sequence, ancestor::Dict{Int,Array{Interval}})\n\nReturn the ancestral tiling imprinted upon Sequence s. Modifies ancestor in place.\n\n\n\n\n\n","category":"method"},{"location":"lib/simulate/#PanGraph.Simulation.pancontigs-Tuple{Array{Vector{UInt64}}}","page":"Simulation","title":"PanGraph.Simulation.pancontigs","text":"pancontigs(s::Sequence)\n\nReturn the ancestral tiling imprinted upon a set of Sequences isolates.\n\n\n\n\n\n","category":"method"},{"location":"lib/simulate/#PanGraph.Simulation.run-Tuple{Function, Int64, Vector{Vector{UInt8}}}","page":"Simulation","title":"PanGraph.Simulation.run","text":"run(evolve!::Function, time::Int, initial::Array{Array{UInt8,1},1}; graph=false)\n\nThe high level API of the module. Evolves a set of initial sequences initial for time generations using the one-step evolution function evolve! If graph is true, the function will return the pangraph associated to the ancestral tiling.\n\n\n\n\n\n","category":"method"},{"location":"cli/generate/#Generate","page":"Generate","title":"Generate","text":"","category":"section"},{"location":"cli/generate/#Description","page":"Generate","title":"Description","text":"","category":"section"},{"location":"cli/generate/","page":"Generate","title":"Generate","text":"Generate a simulated multiple sequence alignment pangraph.","category":"page"},{"location":"cli/generate/#Options","page":"Generate","title":"Options","text":"","category":"section"},{"location":"cli/generate/","page":"Generate","title":"Generate","text":"Name Type Short Flag Long Flag Description\nMutation rate Float m snp-rate Rate of mutations per site per genome per generation\nHGT rate Float r hgt-rate Rate of horizontal transfer events per genome per generation\nDeletion rate Float d delete-rate Rate of deletion events per genome per generation\nInversion rate Float i invert-rate Rate of inversion events per genome per generation\nGraph output String o output-path Path to location to store simulated pangraph\nTime Integer t time Number of generations to simulate before computing sequences and graph","category":"page"},{"location":"cli/generate/#Arguments","page":"Generate","title":"Arguments","text":"","category":"section"},{"location":"cli/generate/","page":"Generate","title":"Generate","text":"Zero or one fasta file to treat as ancestral sequences. If no file path is given, reads from stdin. In either case, the stream can be optionally gzipped. The number and length of sequences determine the population size.","category":"page"},{"location":"cli/generate/#Output","page":"Generate","title":"Output","text":"","category":"section"},{"location":"cli/generate/","page":"Generate","title":"Generate","text":"Outputs all resultant sequences to standard out. Optionally output the resultant pangraph if a path is supplied by the user.","category":"page"},{"location":"lib/path/#Paths","page":"Paths","title":"Paths","text":"","category":"section"},{"location":"lib/path/#Types","page":"Paths","title":"Types","text":"","category":"section"},{"location":"lib/path/","page":"Paths","title":"Paths","text":"Modules = [PanGraph.Graphs.Paths]\nOrder = [:type, :constant]","category":"page"},{"location":"lib/path/#PanGraph.Graphs.Paths.Link","page":"Paths","title":"PanGraph.Graphs.Paths.Link","text":"Link = NamedTuple{(:block, :strand), Tuple{Block, Bool}}\n\nA shorthand wrapper for an abstract Node object.\n\n\n\n\n\n","category":"type"},{"location":"lib/path/#PanGraph.Graphs.Paths.Path","page":"Paths","title":"PanGraph.Graphs.Paths.Path","text":"mutable struct Path\n\tname     :: String\n\tnode     :: Array{Node{Block}}\n\toffset   :: Union{Int,Nothing}\n\tcircular :: Bool\n\tposition :: Array{Int}\nend\n\nPath is a single genome entry within the pangraph. name stores the unique identifier of the genome. node is an array of Nodes. The concatenation of all Nodes recapitulates the original sequence. offset is the circular shift that must be applied to the concatenation to retain the original starting positition. It is nothing if the Path is linear. circular is true only if the path should be considered circular, i.e. the last node is implictly connected to the first node. position represents the array of breakpoints each node corresponds to.\n\n\n\n\n\n","category":"type"},{"location":"lib/path/#PanGraph.Graphs.Paths.Path-Tuple{String, PanGraph.Graphs.Nodes.Node{PanGraph.Graphs.Blocks.Block}}","page":"Paths","title":"PanGraph.Graphs.Paths.Path","text":"Path(name::String,node::Node{Block};circular::Bool=false)\n\nReturn a new Path structure obtained from a single node and name name.  By default will be interpreted as a linear path.\n\n\n\n\n\n","category":"method"},{"location":"lib/path/#Functions","page":"Paths","title":"Functions","text":"","category":"section"},{"location":"lib/path/","page":"Paths","title":"Paths","text":"Modules = [PanGraph.Graphs.Paths]\nOrder = [:function]","category":"page"},{"location":"lib/path/#Base.length-Tuple{PanGraph.Graphs.Paths.Path}","page":"Paths","title":"Base.length","text":"length(p::Path)\n\nReturn the number of nodes associated to Path p.\n\n\n\n\n\n","category":"method"},{"location":"lib/path/#Base.replace!-Tuple{PanGraph.Graphs.Paths.Path, Array{NamedTuple{(:block, :strand), Tuple{PanGraph.Graphs.Blocks.Block, Bool}}}, PanGraph.Graphs.Blocks.Block}","page":"Paths","title":"Base.replace!","text":"replace!(p::Path, old::Array{Link}, new::Block)\n\nReplace all instances of oriented Block list old with the single block new. Operates on Path p in place.\n\n\n\n\n\n","category":"method"},{"location":"lib/path/#Base.replace!-Tuple{PanGraph.Graphs.Paths.Path, PanGraph.Graphs.Blocks.Block, Array{PanGraph.Graphs.Blocks.Block}, Bool}","page":"Paths","title":"Base.replace!","text":"replace!(p::Path, old::Block, new::Array{Block}, orientation::Bool)\n\nReplace all instances of Block old with the array of blocks new. Operates on Path p in place. orientation is the relative orientation assumed between old and new, i.e. if it is false, new is assumed to be the reverse complement of old.\n\n\n\n\n\n","category":"method"},{"location":"lib/path/#PanGraph.Graphs.Paths.count_isolates-Tuple{Any}","page":"Paths","title":"PanGraph.Graphs.Paths.count_isolates","text":"count_isolates(paths)\n\nReturn the number of times each isolate within paths appears in each block.\n\n\n\n\n\n","category":"method"},{"location":"lib/path/#PanGraph.Graphs.Paths.positions!-Tuple{PanGraph.Graphs.Paths.Path}","page":"Paths","title":"PanGraph.Graphs.Paths.positions!","text":"positions!(p::Path)\n\nCompute the positions of each breakpoint represented by a node in Path p. Modifies p in place.\n\n\n\n\n\n","category":"method"},{"location":"lib/path/#PanGraph.Graphs.sequence-Tuple{PanGraph.Graphs.Paths.Path}","page":"Paths","title":"PanGraph.Graphs.sequence","text":"sequence(p::Path; shift=true)\n\nReturn the reconstructed sequence of Path p. If shift is false, the circular offset will be ignored.\n\n\n\n\n\n","category":"method"},{"location":"lib/graph/#Graphs","page":"Graphs","title":"Graphs","text":"","category":"section"},{"location":"lib/graph/","page":"Graphs","title":"Graphs","text":"CurrentModule = PanGraph","category":"page"},{"location":"lib/graph/#Types","page":"Graphs","title":"Types","text":"","category":"section"},{"location":"lib/graph/","page":"Graphs","title":"Graphs","text":"Modules = [Graphs]\nOrder = [:type, :constant]","category":"page"},{"location":"lib/graph/#PanGraph.Graphs.DelMap","page":"Graphs","title":"PanGraph.Graphs.DelMap","text":"DelMap = Dict{Int,Int}\n\nA sparse array of deletion events relative to a consensus. The key is the locus (inclusive) of the deletion; the value is the length.\n\n\n\n\n\n","category":"type"},{"location":"lib/graph/#PanGraph.Graphs.Graph","page":"Graphs","title":"PanGraph.Graphs.Graph","text":"struct Graph\n    block    :: Dict{String, Block}\n    sequence :: Dict{String, Path}\nend\n\nRepresentation of a multiple sequence alignment. Alignments of homologous sequences are stored as blocks. A genome is stored as a path, i.e. a list of blocks.\n\n\n\n\n\n","category":"type"},{"location":"lib/graph/#PanGraph.Graphs.Graph-Tuple{String, Array{UInt8}}","page":"Graphs","title":"PanGraph.Graphs.Graph","text":"Graph(name::String, sequence::Array{UInt8}; circular=false)\n\nCreates a singleton graph from sequence. name is assumed to be a unique identifier. If circular is unspecified, the sequence is assumed to be linear.\n\n\n\n\n\n","category":"method"},{"location":"lib/graph/#PanGraph.Graphs.InsMap","page":"Graphs","title":"PanGraph.Graphs.InsMap","text":"InsMap = Dict{Tuple{Int,Int},Array{UInt8,1}}\n\nA sparse array of insertion sequences relative to a consensus. The key is the (locus(after),offset) of the insertion; the value is the sequence.\n\n\n\n\n\n","category":"type"},{"location":"lib/graph/#PanGraph.Graphs.SNPMap","page":"Graphs","title":"PanGraph.Graphs.SNPMap","text":"SNPMap = Dict{Int,UInt8}\n\nA sparse array of single nucleotide polymorphisms relative to a consensus. The key is the locus of the mutation; the value is the modified nucleotide.\n\n\n\n\n\n","category":"type"},{"location":"lib/graph/#Functions","page":"Graphs","title":"Functions","text":"","category":"section"},{"location":"lib/graph/","page":"Graphs","title":"Graphs","text":"Modules = [Graphs]\nOrder = [:function]","category":"page"},{"location":"lib/graph/#PanGraph.Graphs.detransitive!-Tuple{PanGraph.Graphs.Graph}","page":"Graphs","title":"PanGraph.Graphs.detransitive!","text":"detransitive!(G::Graph)\n\nFind and remove all transitive edges within the given graph. A transitive chain of edges is defined to be unambiguous: all sequences must enter on one edge and leave on another. Thus, this will not perform paralog splitting.\n\n\n\n\n\n","category":"method"},{"location":"lib/graph/#PanGraph.Graphs.finalize!-Tuple{Any}","page":"Graphs","title":"PanGraph.Graphs.finalize!","text":"finalize!(G::Graph)\n\nCompute the position of the breakpoints for each homologous alignment across all sequences within Graph G. Intended to be ran after multiple sequence alignment is complete\n\n\n\n\n\n","category":"method"},{"location":"lib/graph/#PanGraph.Graphs.graphs-Tuple{IO}","page":"Graphs","title":"PanGraph.Graphs.graphs","text":"graphs(io::IO; circular=false)\n\nParse a fasta file from stream io and return an array of singleton graphs. If circular is unspecified, all genomes are assumed to be linear.\n\n\n\n\n\n","category":"method"},{"location":"lib/graph/#PanGraph.Graphs.keeponly!-Union{Tuple{T}, Tuple{PanGraph.Graphs.Graph, Vararg{T}}} where T<:AbstractString","page":"Graphs","title":"PanGraph.Graphs.keeponly!","text":"keeponly!(G::Graph, names::String...)\n\nRemove all sequences from graph G that are passed as variadic parameters names. This will marginalize a graph, i.e. return the subgraph that contains only isolates contained in names\n\n\n\n\n\n","category":"method"},{"location":"lib/graph/#PanGraph.Graphs.marshal_fasta-Tuple{IO, PanGraph.Graphs.Graph}","page":"Graphs","title":"PanGraph.Graphs.marshal_fasta","text":"marshal_fasta(io::IO, G::Graph; opt=nothing)\n\nSerialize graph G as a fasta format output stream io. Importantly, this will only serialize the consensus sequences for each block and not the full multiple sequence alignment.\n\nopt is currently ignored. It is kept for signature uniformity for other marshal functions\n\n\n\n\n\n","category":"method"},{"location":"lib/graph/#PanGraph.Graphs.marshal_json-Tuple{IO, PanGraph.Graphs.Graph}","page":"Graphs","title":"PanGraph.Graphs.marshal_json","text":"marshal_json(io::IO, G::Graph; opt=nothing)\n\nSerialize graph G as a json format output stream io. This is the main storage/exported format for PanGraph. Currently it is the only format that can reconstruct an in-memory pangraph.\n\nopt is currently ignored. It is kept for signature uniformity for other marshal functions\n\n\n\n\n\n","category":"method"},{"location":"lib/graph/#PanGraph.Graphs.prune!-Tuple{PanGraph.Graphs.Graph}","page":"Graphs","title":"PanGraph.Graphs.prune!","text":"prune!(G::Graph)\n\nRemove all blocks from graph G that are not currently used by any extant sequence. Internal function used during guide tree alignment.\n\n\n\n\n\n","category":"method"},{"location":"lib/graph/#PanGraph.Graphs.purge!-Tuple{PanGraph.Graphs.Graph}","page":"Graphs","title":"PanGraph.Graphs.purge!","text":"purge!(G::Graph)\n\nRemove all blocks from paths found in graph G that have zero length. Internal function used during guide tree alignment.\n\n\n\n\n\n","category":"method"},{"location":"lib/graph/#PanGraph.Graphs.realign!-Tuple{PanGraph.Graphs.Graph}","page":"Graphs","title":"PanGraph.Graphs.realign!","text":"realign!(G::Graph; accept)\n\nRealign blocks contained within graph G. Usage of this function requires MAFFT to be on the system PATH accept should be a function that returns true on blocks you wish to realign. By default, all blocks are realigned.\n\n\n\n\n\n","category":"method"},{"location":"lib/graph/#PanGraph.Graphs.sequence-Tuple{PanGraph.Graphs.Graph, AbstractString}","page":"Graphs","title":"PanGraph.Graphs.sequence","text":"sequence(G::Graph, name::String)\n\nReturn the sequence corresponding to genome name within graph G\n\n\n\n\n\n","category":"method"},{"location":"lib/graph/#PanGraph.Graphs.sequence-Tuple{PanGraph.Graphs.Graph}","page":"Graphs","title":"PanGraph.Graphs.sequence","text":"sequence(G::Graph)\n\nReturn all pairs of name => sequence encoded within graph G\n\n\n\n\n\n","category":"method"},{"location":"lib/graph/#PanGraph.Graphs.test","page":"Graphs","title":"PanGraph.Graphs.test","text":"test(path)\n\nAlign all sequences found in the fasta file at path into a pangraph. Verifies that after the alignment is complete, all sequences are correctly reconstructed\n\n\n\n\n\n","category":"function"},{"location":"lib/graph/#PanGraph.Graphs.unmarshal-Tuple{Any}","page":"Graphs","title":"PanGraph.Graphs.unmarshal","text":"unmarshal(io::IO)\n\nDeserialize the json formatted input stream io into a Graph data structure. Return a Graph type.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/tutorial_3/#Polishing-the-pangraph-and-exploring-alignments","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"","category":"section"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"This third tutorial is focused on block alignments and is divided in three main parts:","category":"page"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"refining the block alignments using the polish command.\nexporting the alignment (and related phylogenetic tree) of each block.\nexploring the full set of block alignments using the panX[1] visualization.","category":"page"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"[1]: Ding, Wei, Franz Baumdicker, and Richard A. Neher. \"panX: pan-genome analysis and exploration.\" Nucleic acids research 46.1 (2018): e5-e5.","category":"page"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"note: Requirements\nExporting files for the panX visualization requires fasttree. Running the panX visualization requires node.js.","category":"page"},{"location":"tutorials/tutorial_3/#Polishing-the-alignments","page":"Polishing the pangraph and exploring alignments","title":"Polishing the alignments","text":"","category":"section"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"The pangenome graph is built by iterative pairwise merges of smaller graphs along a guide tree. At each stage blocks are compared and aligned using only their consensus. This shortens considerably the time needed to build a pangraph, but might introduce minor inconsistencies and artifacts in the alignments. These can be removed using the polish command which reconstructs the sequences in the block and performs a multiple sequence alignment (e.g. using mafft) (see Polish).","category":"page"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"To polish the ecoli_pangraph.json file that was produced in the first tutorial we can run the command:","category":"page"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"pangraph polish ecoli_pangraph.json > polished_pangraph.json","category":"page"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"This should complete in 10/15 minutes on 4 cores. Optionally, a threshold length can be specified with the flag --length. In this case only alignments of blocks whose consensus sequence is shorter than this threshold are refined.","category":"page"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"Note that the only effect of this command is refining the alignments, but the \"topological\" structure of the pangraph is left unchanged. As such, polishing a pangraph is only useful when one is directly interested in block alignments.","category":"page"},{"location":"tutorials/tutorial_3/#Export-block-alignments-and-trees","page":"Polishing the pangraph and exploring alignments","title":"Export block alignments and trees","text":"","category":"section"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"By running the export command with the --export-panX option (see Export) one can export all the block alignments, together with additional files that are needed for the panX visualization. For our example we can run:","category":"page"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"pangraph export \\\n    --export-panX \\\n    --output-directory ecoli_export \\\n    --no-export-gfa \\\n    polished_pangraph.json","category":"page"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"The flag --no-export-gfa excludes the export in gfa format that we covered in the first tutorial. This command should run in about 15 minutes. It will generate a folder named ecoli_export/vis that contain multiple files. These include:","category":"page"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"the alignment of each block (geneCluster/*_aln.fa.gz files)\nthe phylogenetic tree generated from each alignment (geneCluster/*.nwk files)\nthe phylogenetic tree obtained from the concatenated alignment of all core blocks (strain_tree.nwk)\nadditional files needed for the panX visualization","category":"page"},{"location":"tutorials/tutorial_3/#Accessing-block-alignments-and-trees","page":"Polishing the pangraph and exploring alignments","title":"Accessing block alignments and trees","text":"","category":"section"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"The file geneCluster.json contains the index of all block alignments. It consists of a list with one entry per block. Here is an example of an entry:","category":"page"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"{\n    \"GName\": \"none\",\n    \"geneLen\": 114,       // length of block in bp\n    \"dup_detail\": \"\",\n    \"geneId\": 1129,\n    \"allGName\": \"none\",\n    \"count\": 5,           // tot n. of block occurrences\n    \"locus\": [            // list of \"strain # node number\"\n        \"NZ_CP010150#1\",\n        \"NZ_CP010183#1\",\n        \"NZ_CP015912#1\",\n        \"NC_013361#1\",\n        \"NZ_CP019944#1\"\n    ],\n    \"msa\": \"RC00001129\",  // Id assigned to the alignment.\n    \"divers\": 0.03508771929824561,\n    \"ann\": \"SXSJVKIOIY\",  // block id\n    \"dupli\": \"no\",        // whether the block is duplicated\n    \"allAnn\": \"SXSJVKIOIY\"\n},","category":"page"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"The most important properties of this object are:[2]","category":"page"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"ann: block id.\nmsa: id assigned to the block alignment by the export function. This is the prefix of the corresponding alignment file.\ngeneLen: length of the consensus sequence of the block.\ncount: total number of occurrences of the block.\nlocus: list of block occurrences (nodes). Each one is labeled as \"strain # node number\".\ndupli: whether the block is duplicated in some strain.","category":"page"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"[2]: The names of these entries was assigned so as to be compatible with the panX visualization, which uses genes instead of blocks. This is why for example the length is saved as geneLen, even though the pangenome graph and blocks do not contain gene annotations.","category":"page"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"In particular, the msa property provides the prefix of the file containing the block alignment and the phylogenetic tree. In the example above, the nucleotide alignment for block SXSJVKIOIY can be found in file geneCluster/RC00001129_na_aln.fa.gz, and the corresponding phylogenetic tree is RC00001129.nwk.","category":"page"},{"location":"tutorials/tutorial_3/#Explore-block-alignments-with-the-panX-visualization","page":"Polishing the pangraph and exploring alignments","title":"Explore block alignments with the panX visualization","text":"","category":"section"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"This export format was designed to be compatible with the panX visualization. This visualization was originally created for exploring gene clusters, but it is equally informative if one uses block alignments instead of gene alignments. The panX repository linked above contains instructions on how to set up the visualization.","category":"page"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"For our example we need to:","category":"page"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"clone the repository and perform the setup\nadd a new page to the visualization for our example data\ncopy the export file we previously created into the apposite folder\nstart the server","category":"page"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"this can be done with the command:","category":"page"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"# clone the repository, access it and install packages\ngit clone https://github.com/neherlab/pan-genome-visualization\ncd pan-genome-visualization\ngit submodule update --init\nnpm install\n\n# add a new page for our dataset named Ecoli, with wide format\nbash add-new-pages-repo.sh Ecoli wide\n\n# copy pangraph exported files into the appropriate panx directory\ncp -r ../ecoli_export/vis/* public/dataset/Ecoli/\n\n# start the server\nnpm start","category":"page"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"Once the server has started, the visualization can be accessed at http://localhost:8000/Ecoli.","category":"page"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"(Image: img)","category":"page"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"Here is a summary of the information displayed in different panels:","category":"page"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"A: rank plot of block counts. The initial peak is represented by duplicated blocks (more than 10 counts). Core blocks are found in the plateau at count equal to 10. Rare blocks populate the tail of the plot.\nB: distribution of block lengths. The longest blocks in our example have length of more than 50 kbps.\nC: table relating block id (annotation) to number of counts (#Strains), whether the block is duplicated, average diversity, and length of the consensus sequence in basepairs.\nD: visualization of the block alignment for the block selected in panel C. Entries are labeled according to the strain and the number of block occurrence.\nE: comparison of the core-block tree (left, phylogenetic tree constructed from the concatenated alignment of all core blocks) and the tree reconstructed from the alignment selected in panel C (right).","category":"page"},{"location":"tutorials/tutorial_3/","page":"Polishing the pangraph and exploring alignments","title":"Polishing the pangraph and exploring alignments","text":"This visualization makes it easy to quickly explore the data. For example if we order the blocks by number of counts we find that the most duplicated block has 86 counts and consensus length of 768 bp, From panel D we can easily download the alignment and if we run BLAST on the sequence we discover that it contains the genetic sequence of a transposase.","category":"page"},{"location":"cli/polish/#Polish","page":"Polish","title":"Polish","text":"","category":"section"},{"location":"cli/polish/#Description","page":"Polish","title":"Description","text":"","category":"section"},{"location":"cli/polish/","page":"Polish","title":"Polish","text":"Realigns blocks of a multiple sequence alignment pangraph with an external multiple sequence alignment tool.","category":"page"},{"location":"cli/polish/#Options","page":"Polish","title":"Options","text":"","category":"section"},{"location":"cli/polish/","page":"Polish","title":"Polish","text":"Name Type Short Flag Long Flag Description\nMaximum Length Integer l length cutoff above which the block is not realigned externally\nPreserve Case Bool c preserve-case ensure case (upper/lower) is preserved after realignment","category":"page"},{"location":"cli/polish/#Arguments","page":"Polish","title":"Arguments","text":"","category":"section"},{"location":"cli/polish/","page":"Polish","title":"Polish","text":"Zero or one pangraph file which must be formatted as a JSON. If no file path is given, reads from stdin. In either case, the stream can be optionally gzipped.","category":"page"},{"location":"cli/polish/#Output","page":"Polish","title":"Output","text":"","category":"section"},{"location":"cli/polish/","page":"Polish","title":"Polish","text":"Outputs the polished pangraph to stdout.","category":"page"},{"location":"lib/utility/#Utility","page":"Utility","title":"Utility","text":"","category":"section"},{"location":"lib/utility/#Types","page":"Utility","title":"Types","text":"","category":"section"},{"location":"lib/utility/","page":"Utility","title":"Utility","text":"Modules = [PanGraph.Graphs.Utility]\nOrder = [:type, :constant]","category":"page"},{"location":"lib/utility/#PanGraph.Graphs.Utility.Alignment","page":"Utility","title":"PanGraph.Graphs.Utility.Alignment","text":"mutable struct Alignment{T <: Union{String,Nothing,Array{Tuple{Int,Char}}}}\n\tqry::Hit\n\tref::Hit\n\tmatches::Int\n\tlength::Int\n\tquality::Int\n\torientation::Bool\n\tcigar::T\n\tdivergence::Union{Float64,Nothing}\n\talign::Union{Float64,Nothing}\nend\n\nAlignment is a pairwise homologous alignment between two sequences.\n\n\n\n\n\n","category":"type"},{"location":"lib/utility/#PanGraph.Graphs.Utility.Hit","page":"Utility","title":"PanGraph.Graphs.Utility.Hit","text":"mutable struct Hit\n\tname::String\n\tlength::Int\n\tstart::Int\n\tstop::Int\n\tseq::Maybe{Array{UInt8,1}}\nend\n\nHit is one side of a pairwise alignment between homologous sequences.\n\n\n\n\n\n","category":"type"},{"location":"lib/utility/#PanGraph.Graphs.Utility.Record","page":"Utility","title":"PanGraph.Graphs.Utility.Record","text":"struct Record\n\tseq::Array{UInt8}\n\tname::String\n\tmeta::String\nend\n\nA record obtained when parsing a single entry of a FASTA file.\n\n\n\n\n\n","category":"type"},{"location":"lib/utility/#PanGraph.Graphs.Utility.Score","page":"Utility","title":"PanGraph.Graphs.Utility.Score","text":"struct Score <: AbstractArray{Float64,2}\n\trows::Int\n\tcols::Int\n\tband::NamedTuple{(:lower, :upper)}\n\tdata::Array{Float64}\n\toffset::Array{Int}\n\tstarts::Array{Int}\n\tstops::Array{Int}\nend\n\nStore information about a banded pairwise alignment.\n\n\n\n\n\n","category":"type"},{"location":"lib/utility/#PanGraph.Graphs.Utility.cost","page":"Utility","title":"PanGraph.Graphs.Utility.cost","text":"cost = (\n\topen   = -6.0,\n\textend = -1.0,\n\tband   = (\n\t\tlower = Inf,\n\t\tupper = Inf,\n\t),\n\tgap    = k -> k == 0 ? 0 : cost.open + cost.extend*(k-1),\n\tmatch  = (c₁, c₂) -> 6.0*(c₁ == c₂) - 3.0,\n)\n\ncost are the default dynamic alignment parameters used.\n\n\n\n\n\n","category":"constant"},{"location":"lib/utility/#Functions","page":"Utility","title":"Functions","text":"","category":"section"},{"location":"lib/utility/","page":"Utility","title":"Utility","text":"Modules = [PanGraph.Graphs.Utility]\nOrder = [:function]","category":"page"},{"location":"lib/utility/#PanGraph.Graphs.Utility.align-Tuple{Array{UInt8}, Array{UInt8}, Any}","page":"Utility","title":"PanGraph.Graphs.Utility.align","text":"align(seq₁::Array{UInt8}, seq₂::Array{UInt8}, cost::Score)\n\nPerform a pairwise alignment using Needleman-Wunsch style dynamic programming between seq₁ and seq₂ given cost. The cost is defined by the Score structure.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#PanGraph.Graphs.Utility.cigar-Tuple{Array{UInt8}, Array{UInt8}}","page":"Utility","title":"PanGraph.Graphs.Utility.cigar","text":"cigar(seq₁::Array{UInt8}, seq₂::Array{UInt8})\n\nGiven two sequences, seq₁ and seq₂, perform a pairwise banded alignment and return the cigar string of alignment.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#PanGraph.Graphs.Utility.columns-Tuple{Any}","page":"Utility","title":"PanGraph.Graphs.Utility.columns","text":"columns(s; nc=80)\n\nPartition string s into an array of strings such that no string is longer than nc characters.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#PanGraph.Graphs.Utility.enforce_cutoff!-Tuple{PanGraph.Graphs.Utility.Alignment, Any}","page":"Utility","title":"PanGraph.Graphs.Utility.enforce_cutoff!","text":"enforce_cutoff!(a::Alignment, χ)\n\nEnsure that the alignment a does not have insertion or deletion segments larger than χ. Return the list of segments created by parsing the alignment such that all segments are larger than χ.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#PanGraph.Graphs.Utility.hamming_align-Tuple{Vector{UInt8}, Vector{UInt8}}","page":"Utility","title":"PanGraph.Graphs.Utility.hamming_align","text":"hamming_align(qry::Array{UInt8,1}, ref::Array{UInt8,1})\n\nPerform a simple alignment of qry to ref by minimizing hamming distance. Useful for fast, approximate alignments of small sequences.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#PanGraph.Graphs.Utility.random_id-Tuple{}","page":"Utility","title":"PanGraph.Graphs.Utility.random_id","text":"random_id(;len=10, alphabet=UInt8[])\n\nGenerate a random string of length len drawn from letters in alphabet.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#PanGraph.Graphs.Utility.read_fasta-Tuple{IO}","page":"Utility","title":"PanGraph.Graphs.Utility.read_fasta","text":"read_fasta(io::IO)\n\nParse a FASTA file from IO stream io. Return an iterator over all records.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#PanGraph.Graphs.Utility.read_paf-Tuple{IO}","page":"Utility","title":"PanGraph.Graphs.Utility.read_paf","text":"read_paf(io::IO)\n\nParse a PAF file from IO stream io. Return an iterator over all pairwise alignments.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#PanGraph.Graphs.Utility.uncigar-Tuple{String}","page":"Utility","title":"PanGraph.Graphs.Utility.uncigar","text":"uncigar(cg::String)\n\nReturn an interator over intervals of alignment defined by cigar string cg.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#PanGraph.Graphs.Utility.write_fasta-Tuple{IO, Any, Any}","page":"Utility","title":"PanGraph.Graphs.Utility.write_fasta","text":"write_fasta(io::IO, name, seq)\n\nOutput a single FASTA record with sequence seq and name name to IO stream io.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#PanGraph.Graphs.reverse_complement!-Tuple{PanGraph.Graphs.Utility.Hit}","page":"Utility","title":"PanGraph.Graphs.reverse_complement!","text":"reverse_complement!(hit::Hit)\n\nReverse complement the qry of Hit in place.\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#PanGraph.Graphs.reverse_complement-Tuple{Array{UInt8}}","page":"Utility","title":"PanGraph.Graphs.reverse_complement","text":"reverse_complement(seq::Array{UInt8})\n\nReturn a newly allocated sequence array that is the reverse complement of seq.\n\n\n\n\n\n","category":"method"},{"location":"cli/marginalize/#Marginalize","page":"Marginalize","title":"Marginalize","text":"","category":"section"},{"location":"cli/marginalize/#Description","page":"Marginalize","title":"Description","text":"","category":"section"},{"location":"cli/marginalize/","page":"Marginalize","title":"Marginalize","text":"Compute all pairwise marginalizations of a multiple sequence alignment pangraph.","category":"page"},{"location":"cli/marginalize/#Options","page":"Marginalize","title":"Options","text":"","category":"section"},{"location":"cli/marginalize/","page":"Marginalize","title":"Marginalize","text":"Name Type Short Flag Long Flag Description\nOutput path String o output-path Path to direcotry where the output of all pairwise mariginalizations will be stored if supplied\nReduce paralogs Boolean r reduce-paralog Collapses coparallel paths through duplicated blocks.\nProjection strains String s Strains Collapses the graph structure to only blocks and edges contained by the paths of the supplied strain names. comma seperated, no spaces","category":"page"},{"location":"cli/marginalize/#Arguments","page":"Marginalize","title":"Arguments","text":"","category":"section"},{"location":"cli/marginalize/","page":"Marginalize","title":"Marginalize","text":"Zero or one pangraph file which must be formatted as a JSON. If no file path is given, reads from stdin. In either case, the stream can be optionally gzipped.","category":"page"},{"location":"cli/marginalize/#Output","page":"Marginalize","title":"Output","text":"","category":"section"},{"location":"cli/marginalize/","page":"Marginalize","title":"Marginalize","text":"Outputs all pairwise graphs to the directory at the user-supplied path.","category":"page"},{"location":"lib/align/#Alignment","page":"Alignment","title":"Alignment","text":"","category":"section"},{"location":"lib/align/#Types","page":"Alignment","title":"Types","text":"","category":"section"},{"location":"lib/align/","page":"Alignment","title":"Alignment","text":"Modules = [PanGraph.Graphs.Align]\nOrder = [:type, :constant]","category":"page"},{"location":"lib/align/#PanGraph.Graphs.Align.Clade","page":"Alignment","title":"PanGraph.Graphs.Align.Clade","text":"mutable struct Clade\n\tname   :: String\n\tparent :: Union{Clade,Nothing}\n\tleft   :: Union{Clade,Nothing}\n\tright  :: Union{Clade,Nothing}\n\tgraph  :: Channel{Graph}\nend\n\nClade is a node (internal or leaf) of a binary guide tree used to order pairwise alignments associated to a multiple genome alignment in progress. name is only non-empty for leaf nodes. parent is nothing for the root node. graph is a 0-sized channel that is used as a message passing primitive in alignment.\n\n\n\n\n\n","category":"type"},{"location":"lib/align/#PanGraph.Graphs.Align.Clade-Tuple{Any, Any}","page":"Alignment","title":"PanGraph.Graphs.Align.Clade","text":"Clade(distance, names; algo=:nj)\n\nGenerate a tree from a matrix of pairwise distances distance. The names of leafs are given by an array of strings names. algo dictates the algorithm used to transform the distance matrix into a tree. Currently on neighbor joining (:nj) is supported.\n\n\n\n\n\n","category":"method"},{"location":"lib/align/#PanGraph.Graphs.Align.Clade-Tuple{Any}","page":"Alignment","title":"PanGraph.Graphs.Align.Clade","text":"Clade(name)\n\nGenerate an empty, disconnected clade with name name.\n\n\n\n\n\n","category":"method"},{"location":"lib/align/#PanGraph.Graphs.Align.Clade-Tuple{PanGraph.Graphs.Align.Clade, PanGraph.Graphs.Align.Clade}","page":"Alignment","title":"PanGraph.Graphs.Align.Clade","text":"Clade(left::Clade, right::Clade)\n\nGenerate an nameless clade with left and right children.\n\n\n\n\n\n","category":"method"},{"location":"lib/align/#PanGraph.Graphs.Align.Clade-Tuple{}","page":"Alignment","title":"PanGraph.Graphs.Align.Clade","text":"Clade()\n\nGenerate an empty, disconnected clade.\n\n\n\n\n\n","category":"method"},{"location":"lib/align/#Functions","page":"Alignment","title":"Functions","text":"","category":"section"},{"location":"lib/align/","page":"Alignment","title":"Alignment","text":"Modules = [PanGraph.Graphs.Align]\nOrder = [:function]","category":"page"},{"location":"lib/align/#PanGraph.Graphs.Align.align-Tuple{Vararg{PanGraph.Graphs.Graph}}","page":"Alignment","title":"PanGraph.Graphs.Align.align","text":"align(G::Graph...; compare=Mash.distance, energy=(hit)->(-Inf), minblock=100)\n\nAlign graph G₁ to itself by looking for homology between blocks. Multithreaded by default. This is usually the function you want.\n\nenergy is to be a function that takes an alignment between two blocks and produces a score. The lower the score, the better the alignment. Only negative energies are considered.\n\nminblock is the minimum size block that will be produced from the algorithm. maxiter is maximum number of duplications that will be considered during this alignment.\n\ncompare is the function to be used to generate pairwise distances that generate the internal guide tree.\n\n\n\n\n\n","category":"method"},{"location":"lib/align/#PanGraph.Graphs.Align.align_pair-Tuple{PanGraph.Graphs.Graph, PanGraph.Graphs.Graph, Function, Int64, Function, Bool}","page":"Alignment","title":"PanGraph.Graphs.Align.align_pair","text":"align_pair(G₁::Graph, G₂::Graph, energy::Function, minblock::Int, verify::Function, verbose::Bool; maxiter=100)\n\nAlign graph G₁ to graph G₂ by looking for homology between consensus sequences of blocks. This is a low-level function.\n\nenergy is to be a function that takes an alignment between two blocks and produces a score. The lower the score, the better the alignment. Only negative energies are considered.\n\nminblock is the minimum size block that will be produced from the algorithm. maxiter is maximum number of duplications that will be considered during this alignment.\n\n\n\n\n\n","category":"method"},{"location":"lib/align/#PanGraph.Graphs.Align.align_self-Tuple{PanGraph.Graphs.Graph, Function, Int64, Function, Bool}","page":"Alignment","title":"PanGraph.Graphs.Align.align_self","text":"align_self(G₁::Graph, energy::Function, minblock::Int, verify::Function, verbose::Bool; maxiter=100)\n\nAlign graph G₁ to itself by looking for homology between blocks. This is a low-level function.\n\nenergy is to be a function that takes an alignment between two blocks and produces a score. The lower the score, the better the alignment. Only negative energies are considered.\n\nminblock is the minimum size block that will be produced from the algorithm. maxiter is maximum number of duplications that will be considered during this alignment.\n\n\n\n\n\n","category":"method"},{"location":"lib/align/#PanGraph.Graphs.Align.balance-Tuple{PanGraph.Graphs.Align.Clade}","page":"Alignment","title":"PanGraph.Graphs.Align.balance","text":"balance(root::Clade)\n\nRotate a binary tree to a balanced configuration. Preserves the topological ordering of the leaves.\n\n\n\n\n\n","category":"method"},{"location":"lib/align/#PanGraph.Graphs.Align.isleaf-Tuple{PanGraph.Graphs.Align.Clade}","page":"Alignment","title":"PanGraph.Graphs.Align.isleaf","text":"isleaf(c::Clade)\n\nReturn if Clade c is a terminal node, i.e. a leaf.\n\n\n\n\n\n","category":"method"},{"location":"lib/align/#PanGraph.Graphs.Align.leaves-Tuple{PanGraph.Graphs.Align.Clade}","page":"Alignment","title":"PanGraph.Graphs.Align.leaves","text":"leaves(root::Clade)\n\nReturn all terminal nodes that have root as their common ancestor.\n\n\n\n\n\n","category":"method"},{"location":"lib/align/#PanGraph.Graphs.Align.nj-Tuple{Any, Any}","page":"Alignment","title":"PanGraph.Graphs.Align.nj","text":"nj(distance, names)\n\nLower-level function. Generate a tree from a matrix of pairwise distances distance. The names of leafs are given by an array of strings names. Uses neighbor joining.\n\n\n\n\n\n","category":"method"},{"location":"lib/align/#PanGraph.Graphs.Align.ordering-Tuple{Any, Vararg{Any}}","page":"Alignment","title":"PanGraph.Graphs.Align.ordering","text":"ordering(compare, Gs...)\n\nReturn a guide tree based upon distances computed from a collection of graphs Gs, using method compare. The signature of compare is expected to be compare(G::Graphs....) -> distance, names. Graphs Gs... are expected to be singleton graphs.\n\n\n\n\n\n","category":"method"},{"location":"lib/align/#PanGraph.Graphs.Align.postorder-Tuple{PanGraph.Graphs.Align.Clade}","page":"Alignment","title":"PanGraph.Graphs.Align.postorder","text":"postorder(root::Clade)\n\nReturn an postorder iterator over descendents of root.\n\n\n\n\n\n","category":"method"},{"location":"lib/align/#PanGraph.Graphs.Align.preorder-Tuple{PanGraph.Graphs.Align.Clade}","page":"Alignment","title":"PanGraph.Graphs.Align.preorder","text":"preorder(root::Clade)\n\nReturn an preorder iterator over descendents of root.\n\n\n\n\n\n","category":"method"},{"location":"lib/minimap/#Minimap2-Wrapper","page":"Minimap2 Wrapper","title":"Minimap2 Wrapper","text":"","category":"section"},{"location":"lib/minimap/#Types","page":"Minimap2 Wrapper","title":"Types","text":"","category":"section"},{"location":"lib/minimap/","page":"Minimap2 Wrapper","title":"Minimap2 Wrapper","text":"Modules = [PanGraph.Graphs.Minimap]\nOrder = [:type, :constant]","category":"page"},{"location":"lib/minimap/#PanGraph.Graphs.Minimap.Buffer","page":"Minimap2 Wrapper","title":"PanGraph.Graphs.Minimap.Buffer","text":"struct Buffer\n\thandle :: Ptr{Cvoid}\nend\n\nStore the untyped address to a minimap2 sequence buffer (working space).\n\n\n\n\n\n","category":"type"},{"location":"lib/minimap/#PanGraph.Graphs.Minimap.Extra","page":"Minimap2 Wrapper","title":"PanGraph.Graphs.Minimap.Extra","text":"struct Extra\n\tcapacity :: UInt32\n\tdp_score :: Int32\n\tdp_max   :: Int32\n\tdp_max2  :: Int32\n\tpacked   :: UInt32 # n_ambi (30 bits) / strand (2 bits)\n\tn_cigar  :: UInt32\n\tcigar UInt32[] (variable length array)\nend\n\nCopied from minimap2.h. See mmextrat.\n\n\n\n\n\n","category":"type"},{"location":"lib/minimap/#PanGraph.Graphs.Minimap.Index","page":"Minimap2 Wrapper","title":"PanGraph.Graphs.Minimap.Index","text":"struct Index\n\thandle :: Ptr{Cvoid}\nend\n\nStore the untyped address to a minimap2 sequence index (set of minimizers).\n\n\n\n\n\n","category":"type"},{"location":"lib/minimap/#PanGraph.Graphs.Minimap.IndexOptions","page":"Minimap2 Wrapper","title":"PanGraph.Graphs.Minimap.IndexOptions","text":"struct IndexOptions\n\tk    :: Cshort\n\tw    :: Cshort\n\tflag :: Cshort\n\tbucket_bits :: Cshort\n\tmini_batch_size :: Int64\n\tbatch_size :: UInt64\n\n\tIndexOptions() = new()\nend\n\nCopied from minimap2.h. See mmidxoptt.\n\n\n\n\n\n","category":"type"},{"location":"lib/minimap/#PanGraph.Graphs.Minimap.MapOptions","page":"Minimap2 Wrapper","title":"PanGraph.Graphs.Minimap.MapOptions","text":"mutable struct MapOptions\n\tflag :: Int64\n\tseed :: Cint\n\tsdust_thres :: Cint\n\n\tmax_qlen :: Cint\n\n\tbw :: Cint; bw_long :: Cint\n\tmax_gap :: Cint; max_gap_ref :: Cint \n\tmax_frag_len :: Cint\n\tmax_chain_skip :: Cint; max_chain_iter :: Cint\n\tmin_cnt :: Cint\n\tmin_chain_score :: Cint\n\tchain_gap_scale :: Cfloat\n\trmq_size_cap :: Cint; rmq_inner_dist :: Cint\n\trmq_rescue_size :: Cint\n\trmq_rescue_ratio :: Cfloat\n\n\tmask_level :: Cfloat\n\tmask_len :: Cint\n\tpri_ratio :: Cfloat\n\tbest_n :: Cint\n\n\talt_drop :: Cfloat\n\n\ta :: Cint; b :: Cint; q :: Cint; e :: Cint; q2 :: Cint; e2 :: Cint\n\tsc_ambi :: Cint\n\tnoncan :: Cint \n\tjunc_bonus :: Cint\n\tzdrop :: Cint; zdrop_inv :: Cint\n\tend_bonus :: Cint\n\tmin_dp_max :: Cint\n\tmin_ksw_len :: Cint\n\tanchor_ext_len :: Cint; anchor_ext_shift :: Cint\n\tmax_clip_ratio :: Cfloat\n\n\trank_min_len :: Cint\n\trank_frac :: Cfloat\n\n\tpe_ori :: Cint; pe_bonus :: Cint\n\n\tmid_occ_frac :: Cfloat\n\tmin_mid_occ :: Int32; max_mid_occ :: Int32\n\tmid_occ :: Int32\n\tmax_occ :: Int32; max_max_occ :: Int32; occ_dist :: Int32;\n\tmini_batch_size :: Int64\n\tmax_sw_mat :: Int64\n\tcap_kalloc :: Int64\n\n\tsplit_prefix :: Cstring\nend\n\nCopied from minimap2.h. See mmmapoptt.\n\n\n\n\n\n","category":"type"},{"location":"lib/minimap/#PanGraph.Graphs.Minimap.PanContigs","page":"Minimap2 Wrapper","title":"PanGraph.Graphs.Minimap.PanContigs","text":"struct PanContigs\n\tname     :: T\n\tsequence :: T\nend\n\nA synonym for a consensus sequence of Block.\n\n\n\n\n\n","category":"type"},{"location":"lib/minimap/#PanGraph.Graphs.Minimap.Record","page":"Minimap2 Wrapper","title":"PanGraph.Graphs.Minimap.Record","text":"struct Record\n\tid :: Int32; cnt :: Int32; rid :: Int32; score :: Int32\n\tqs :: Int32; qe  :: Int32; rs  :: Int32; re :: Int32\n\n\tparent :: Int32; subsc :: Int32\n\n\tas     :: Int32\n\tmlen   :: Int32; blen :: Int32\n\tnsub   :: Int32;\n\tscore0 :: Int32;\n\n\tpack :: UInt32 # mapq(8) ; split(2); rev(1); inv(1); sam_pri(1); proper_frag(1); pe_thru(1); seg_split(1); seg_id(8); split_inv(1); is_alt(1); dummy(6)\n\thash :: UInt32\n\tdiv  :: Cfloat\n\tp    :: Ptr{Extra}\nend\n\nCopied from minimap2.h. See mmreg1t.\n\n\n\n\n\n","category":"type"},{"location":"lib/minimap/#Functions","page":"Minimap2 Wrapper","title":"Functions","text":"","category":"section"},{"location":"lib/minimap/","page":"Minimap2 Wrapper","title":"Minimap2 Wrapper","text":"Modules = [PanGraph.Graphs.Minimap]\nOrder = [:function]","category":"page"},{"location":"lib/minimap/#PanGraph.Graphs.Minimap.align-Tuple{PanGraph.Graphs.Minimap.PanContigs, PanGraph.Graphs.Minimap.PanContigs, Int64, String}","page":"Minimap2 Wrapper","title":"PanGraph.Graphs.Minimap.align","text":"align(ref::PanContigs, qry::PanContigs, minblock::Int, preset::String)\n\nCall into minimap to align the set of blocks qry to blocks ref. Preset should be a string ∈ [\"asm5\",\"asm10\",\"asm20\"]. See minimap2 manual for details. This is probably the function you want. If you call into the function specifically, all memory management is taken care of for you.\n\n\n\n\n\n","category":"method"},{"location":"lib/minimap/#PanGraph.Graphs.Minimap.freebuffer-Tuple{PanGraph.Graphs.Minimap.Buffer}","page":"Minimap2 Wrapper","title":"PanGraph.Graphs.Minimap.freebuffer","text":"freebuffer()\n\nFree memory associated to an opaque handle thread buffer\n\n\n\n\n\n","category":"method"},{"location":"lib/minimap/#PanGraph.Graphs.Minimap.freeindex-Tuple{PanGraph.Graphs.Minimap.Index}","page":"Minimap2 Wrapper","title":"PanGraph.Graphs.Minimap.freeindex","text":"freeindex()\n\nFree memory associated to an opaque handle to a sequence index.\n\n\n\n\n\n","category":"method"},{"location":"lib/minimap/#PanGraph.Graphs.Minimap.makebuffer-Tuple{}","page":"Minimap2 Wrapper","title":"PanGraph.Graphs.Minimap.makebuffer","text":"makebuffer()\n\nReturn an opaque handle thread buffer\n\n\n\n\n\n","category":"method"},{"location":"lib/minimap/#PanGraph.Graphs.Minimap.makeindex-NTuple{4, Any}","page":"Minimap2 Wrapper","title":"PanGraph.Graphs.Minimap.makeindex","text":"makeindex(w, k, names, sequence; bucketbits::Int=14)\n\nGiven a window size w and kmer length k, return a handle to a minimizer index for sequences sequence.\n\n\n\n\n\n","category":"method"},{"location":"cli/export/#Export","page":"Export","title":"Export","text":"","category":"section"},{"location":"cli/export/#Description","page":"Export","title":"Description","text":"","category":"section"},{"location":"cli/export/","page":"Export","title":"Export","text":"Export a pangraph to a chosen file format(s)","category":"page"},{"location":"cli/export/#Options","page":"Export","title":"Options","text":"","category":"section"},{"location":"cli/export/","page":"Export","title":"Export","text":"Name Type Short Flag Long Flag Description\nEdge minimum length Integer ell edge-minimum-length blocks below this length cutoff will be ignored for edges in graph\nEdge maximum length Integer elu edge-maximum-length blocks above this length cutoff will be ignored for edges in graph\nEdge minimum depth Integer edl edge-minimum-depth blocks below this depth cutoff will be ignored for edges in graph\nEdge maximum depth Integer edu edge-maximum-depth blocks above this depth cutoff will be ignored for edges in graph\nMinimum length Integer ll minimum-length blocks below this length cutoff will be ignored for export\nMaximum length Integer lu maximum-length blocks above this length cutoff will be ignored for export\nMinimum depth Integer dl minimum-depth blocks below this depth cutoff will be ignored for export\nMaximum depth Integer du maximum-depth blocks above this depth cutoff will be ignored for export\nNo duplications Boolean nd no-duplications do not export any block that contains at least one strain repeated more than once\nOutput directory String o output-directory path to directory where output will be stored\nPrefix String p prefix basename of exported files\nGFA Boolean ng no-export-gfa toggles whether pangraph is exported as GFA.\nPanX Boolean px export-panX toggles whether pangraph is exported to panX visualization compatible format.","category":"page"},{"location":"cli/export/#Arguments","page":"Export","title":"Arguments","text":"","category":"section"},{"location":"cli/export/","page":"Export","title":"Export","text":"Zero or one pangraph file which must be formatted as a JSON. If no file path is given, reads from stdin. In either case, the stream can be optionally gzipped.","category":"page"},{"location":"cli/export/#Output","page":"Export","title":"Output","text":"","category":"section"},{"location":"cli/export/","page":"Export","title":"Export","text":"Outputs the constructed pangraph to the selected formats at the user-supplied paths.","category":"page"},{"location":"#PanGraph","page":"Home","title":"PanGraph","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A fast, self-contained Julia library and command line tool suite that aligns multiple genomes simultaneously.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Microbes don't evolve strictly by vertical descent and modification; in addition, there is persistent lateral exchange of genetic material within their local spatial neighborhood. At the present, explanatory population genetic models exist at both extrema of limits horizontal transfer rate; researchers have a reasonable, quantitative understanding of both asexual and the fully decoupled, single-site, evolution. However, there are currently no satisfactory models, and thus computational tools, in the more realistic intermediate regime, let alone that models which account for any structural variation within a population. In order to investigate such questions empirically in natural populations, we have developed a scalable multiple genome alignment tool, PanGraph, that identifies regions of mutual homology between large sets of closely related genomes. This is expected to be useful to parsimoniously infer horizontal gene transfer events within a community; perform comparative studies of genome gain, loss, and rearrangement dynamics; or simply to compress many related genomes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"PanGraph (short for pangenome graph) builds a graph-based coordinate system for polymorphic variation in a microbial population that generalizes classical linear alignment techniques. The graph is built by progressively aligning pairs of genomes using Minimap2's minimizer-based algorithm, and thus simultaneously aligns all genomes within the population in linear time. The resultant graph represents contiguous intervals of homologous DNA as vertices and every genome as an ordered walk across such vertices. Edges of the graph are unordered and only exist if at least one genome was found to connect both vertices in either the forward or reverse strand. The documentation, and source code, uses the following terminology:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Block/PanContig:  A contiguous interval of sequence that compresses a linear multiple sequence alignment and represents a single vertex within a pangraph.  It is summarized by a consensus sequence, along with the polymorphisms needed for each genome to reconstruct the true sequence.\nNode:  An oriented traversal of a genome through a block, i.e. whether a given genome/duplication traverses a block along the forward or reverse direction.  One genome can have multiple nodes that point to the same block.\nPath:  A sequence of nodes that represent an ordered walk on the graph that reconstructs an input genome.  Can be circular or linear.\nEdge:  A juxtaposition/breakpoint between two blocks found in at least one genome.\nGraph/PanGraph:  A collection of blocks, associated to all recognized intervals of homology, and paths, genomes stored as an ordered walk of nodes.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are multiple ways to install PanGraph (either the library or just command line interface)","category":"page"},{"location":"#From-Julia-REPL","page":"Home","title":"From Julia REPL","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"    (@v1.x) pkg> add https://github.com/neherlab/pangraph.git","category":"page"},{"location":"#From-Command-Line","page":"Home","title":"From Command Line","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"    julia -e 'using Pkg; Pkg.add(\"https://github.com/neherlab/pangraph.git\"); Pkg.build()'","category":"page"},{"location":"#Local-Environment","page":"Home","title":"Local Environment","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Clone the repository.","category":"page"},{"location":"","page":"Home","title":"Home","text":"    git clone https://github.com/neherlab/pangraph.git && cd pangraph","category":"page"},{"location":"","page":"Home","title":"Home","text":"Build the package. This will create a seperate Julia environment for PanGraph","category":"page"},{"location":"","page":"Home","title":"Home","text":"    julia --project=. -e 'using Pkg; Pkg.build()'","category":"page"},{"location":"","page":"Home","title":"Home","text":"Enter the REPL","category":"page"},{"location":"","page":"Home","title":"Home","text":"    julia --project=.","category":"page"},{"location":"#Binary","page":"Home","title":"Binary","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Additionally, pangraph is available as a standalone, relocatable binary that should work on any Linux or MacOSX machine. Releases can be obtained from Github","category":"page"},{"location":"#Optional-dependencies","page":"Home","title":"Optional dependencies","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are a few optional external programs that PanGraph can utilize","category":"page"},{"location":"","page":"Home","title":"Home","text":"Mash can be used to construct a guide tree in place of our internal algorithm.\nMAFFT can be optionally used to polish homologous alignments. Only recommended for short alignments.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In order to invoke functionality from PanGraph, these tools must be installed and available on PATH","category":"page"},{"location":"","page":"Home","title":"Home","text":"For convenience, a script bin/setup-pangraph is provided within the repository to install both dependencies for a Linux machine without access to root. It assumes GNU coreutils are available.","category":"page"},{"location":"#User's-Guide","page":"Home","title":"User's Guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Basic functionality of PanGraph is provided by a command line interface. This includes multiple genome alignment, the export of a genome alignment to various visualization formats, alignment polishing, and genome comparison tool. Additionally, generation of basic synthetic data is included for testing. Multithreading support is baked into the provided binary. Unfortunately, due to limitations in julia, the number of threads is set by the environment variable JULIA_NUM_THREADS","category":"page"},{"location":"","page":"Home","title":"Home","text":"For uncovered use cases, functionality can be added by utilizing the underlying library functions. Please see the high-level overview for definitions of library terminology.","category":"page"},{"location":"#Citing-PanGraph","page":"Home","title":"Citing PanGraph","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Add citation here","category":"page"},{"location":"cli/build/#Build","page":"Build","title":"Build","text":"","category":"section"},{"location":"cli/build/#Description","page":"Build","title":"Description","text":"","category":"section"},{"location":"cli/build/","page":"Build","title":"Build","text":"Build a multiple sequence alignment pangraph.","category":"page"},{"location":"cli/build/#Options","page":"Build","title":"Options","text":"","category":"section"},{"location":"cli/build/","page":"Build","title":"Build","text":"Name Type Short Flag Long Flag Description\nminimum length Integer l len minimum block size for alignment graph (in nucleotides)\nblock cut cost Float a alpha energy cost for introducing block partitions due to alignment merger\nblock junction cost Float b beta energy cost for interblock diversity due to alignment merger\ncircular genomes Boolean c circular toggle if input genomes are circular\npairwise sensitivity String s sensitivity controls the pairwise genome alignment sensitivity. currently only accepts \"5\", \"10\" or \"20\"\nmaximum self-maps Integer x max-self-map maximum number of iterations to perform block self maps per pairwise graph merger\nenforce uppercase Boolean u upper-case toggle if input genomes are set to uppercase characters\ndistance calculator String d distance-backend only accepts \"native\" or \"mash\"","category":"page"},{"location":"cli/build/#Arguments","page":"Build","title":"Arguments","text":"","category":"section"},{"location":"cli/build/","page":"Build","title":"Build","text":"Expects one or more fasta files. Multiple records within one file are treated as separate genomes Fasta files can be optionally gzipped.","category":"page"},{"location":"cli/build/#Output","page":"Build","title":"Output","text":"","category":"section"},{"location":"cli/build/","page":"Build","title":"Build","text":"Prints the constructed pangraph as a JSON to stdout.","category":"page"},{"location":"tutorials/tutorial_1/#Building-a-pangraph","page":"Building a pangraph","title":"Building a pangraph","text":"","category":"section"},{"location":"tutorials/tutorial_1/","page":"Building a pangraph","title":"Building a pangraph","text":"This short tutorial will walk you through the process of generating a pangraph from a set of bacterial genomes. We will also cover how to export the generated pangraph file into other formats.","category":"page"},{"location":"tutorials/tutorial_1/","page":"Building a pangraph","title":"Building a pangraph","text":"Simply put, a pangenome graph (or pangraph for short) is a compressed representation of a set of genomes, in which alignable regions are saved as blocks (or pancontigs) and genomes are represented as paths, i.e. list of blocks.","category":"page"},{"location":"tutorials/tutorial_1/","page":"Building a pangraph","title":"Building a pangraph","text":"(Image: img)","category":"page"},{"location":"tutorials/tutorial_1/#Requirements","page":"Building a pangraph","title":"Requirements","text":"","category":"section"},{"location":"tutorials/tutorial_1/","page":"Building a pangraph","title":"Building a pangraph","text":"The tutorial requires you to have the pangraph command available in your path. Instructions on how to install pangraph can be found in Installation.","category":"page"},{"location":"tutorials/tutorial_1/","page":"Building a pangraph","title":"Building a pangraph","text":"For this tutorial we will use a small dataset containing full chromosomes of 10 Escherichia Coli strains (source: GenBank). For convenience this dataset is available in the pangraph repository (example_dataset/ecoli.fa.gz), and can be downloaded with the command:","category":"page"},{"location":"tutorials/tutorial_1/","page":"Building a pangraph","title":"Building a pangraph","text":"wget https://github.com/neherlab/pangraph/raw/master/example_datasets/ecoli.fa.gz","category":"page"},{"location":"tutorials/tutorial_1/","page":"Building a pangraph","title":"Building a pangraph","text":"This is a single fasta file containing 10 fully assembled bacterial chromosomes, but no plasmids. Note that it is not necessary for all of the data to be packed in a single fasta file. One can also pass multiple fasta files (optionally gzipped) as input to the command to build a pangraph.","category":"page"},{"location":"tutorials/tutorial_1/#Building-the-pangraph","page":"Building a pangraph","title":"Building the pangraph","text":"","category":"section"},{"location":"tutorials/tutorial_1/","page":"Building a pangraph","title":"Building a pangraph","text":"As a first step, we will build a pangraph object from the DNA of the 10 chromosomes. This can be done using the command build (see Build):","category":"page"},{"location":"tutorials/tutorial_1/","page":"Building a pangraph","title":"Building a pangraph","text":"pangraph build --circular ecoli.fa.gz > ecoli_pangraph.json","category":"page"},{"location":"tutorials/tutorial_1/","page":"Building a pangraph","title":"Building a pangraph","text":"The option --circular is used when passing circular DNA sequences, like the bacterial chromosomes that we consider here.","category":"page"},{"location":"tutorials/tutorial_1/","page":"Building a pangraph","title":"Building a pangraph","text":"On a consumer laptop the command should complete in around 10 minutes on 4 cores.","category":"page"},{"location":"tutorials/tutorial_1/","page":"Building a pangraph","title":"Building a pangraph","text":"note: multi-threaded execution\nAll pangraph commands are immediately parallelizable by setting the environment variable JULIA_NUM_THREADS before running the build command. For example, to use 4 cores during the build command:export JULIA_NUM_THREADS=4","category":"page"},{"location":"tutorials/tutorial_1/","page":"Building a pangraph","title":"Building a pangraph","text":"The result is a ecoli_pangraph.json file that contains two main entries: paths and blocks. As represented in the image above, blocks contain information on the nucleotide sequence, while paths are compressed representation for genomes as lists of blocks. The pangraph.json contains all information in the input genomes, which can be reconstructed from the graph without loss.","category":"page"},{"location":"tutorials/tutorial_1/","page":"Building a pangraph","title":"Building a pangraph","text":"Below is a simplified view of the structure of the ecoli_pangraph.json file.","category":"page"},{"location":"tutorials/tutorial_1/","page":"Building a pangraph","title":"Building a pangraph","text":"{\n    \"paths\": [\n        {\n            \"name\": \"NZ_CP010242\",\n            \"blocks\": [ { \"id\": \"NFTNKNMFIC\", ... }, { \"id\": \"YTLSRRNNGL\", ... }, ... ],\n            ...\n        },\n        {\n            \"name\": \"NC_009800\",\n            \"blocks\": [  { \"id\": \"AYYUXVXZXB\", ... },  { \"id\": \"YTLSRRNNGL\", ... }, ... ],\n            ...\n        }\n        ...\n    ],\n    \"blocks\": [\n        { \"id\": \"KZJIDOXBAV\", \"sequence\": \"AAGGTGGGTAATCATTTTGATAAGTGAT...\", ... },\n        { \"id\": \"UOFDTEUSWC\", \"sequence\": \"GTTTTAATGCCAGCAAAAATGGTGAATT...\", ... },\n        ...\n    ]\n}","category":"page"},{"location":"tutorials/tutorial_1/","page":"Building a pangraph","title":"Building a pangraph","text":"Each entry in path has two main properties: the name, corresponding to the sequence identifier in the input fasta file, and the blocks list. The latter is a representation of the genome as a list of blocks, each one identified by its unique id.","category":"page"},{"location":"tutorials/tutorial_1/","page":"Building a pangraph","title":"Building a pangraph","text":"Each entry in the blocks lists corresponds to a different block. Each block is assigned an unique random id composed of 10 capital letters and the consensus sequence of the block.","category":"page"},{"location":"tutorials/tutorial_1/","page":"Building a pangraph","title":"Building a pangraph","text":"More details on the structure of this json file will be covered in the next tutorial section.","category":"page"},{"location":"tutorials/tutorial_1/#Exporting-the-pangraph","page":"Building a pangraph","title":"Exporting the pangraph","text":"","category":"section"},{"location":"tutorials/tutorial_1/","page":"Building a pangraph","title":"Building a pangraph","text":"The pangraph object can also be exported in other more common formats using the command export (see Export).","category":"page"},{"location":"tutorials/tutorial_1/","page":"Building a pangraph","title":"Building a pangraph","text":"pangraph export \\\n    --no-duplications \\\n    --output-directory ecoli_export \\\n    ecoli_pangraph.json","category":"page"},{"location":"tutorials/tutorial_1/","page":"Building a pangraph","title":"Building a pangraph","text":"This will create a folder named ecoli_export that contains two files.","category":"page"},{"location":"tutorials/tutorial_1/","page":"Building a pangraph","title":"Building a pangraph","text":"pangraph.fa: a fasta file containing the consensus sequence for each block.\npangraph.gfa: a Graphical Fragment Assembly file that contains a representation of the pangenome graph structure.","category":"page"},{"location":"tutorials/tutorial_1/","page":"Building a pangraph","title":"Building a pangraph","text":"The latter can be visualized using Bandage. The option --no-duplications causes the export function to avoid including duplicated blocks in the graph representation (they are instead exported as isolated blocks). In our experience this results in a less \"tangled\" visual representation. Below is how the Bandage visualization of this example pangraph looks like. Blocks are colored by frequency, with common blocks (appearing in many different chromosomes) in red and rare blocks (appearing in only a few chromosomes) in black.","category":"page"},{"location":"tutorials/tutorial_1/","page":"Building a pangraph","title":"Building a pangraph","text":"(Image: img)","category":"page"}]
}
